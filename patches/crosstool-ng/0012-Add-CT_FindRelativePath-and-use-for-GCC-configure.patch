From 07e1f368b4d60f61ba56de4884e820eb0e54e4ed Mon Sep 17 00:00:00 2001
From: Ray Donnelly <mingw.android@gmail.com>
Date: Fri, 20 Dec 2013 18:48:25 +0000
Subject: [PATCH 12/21] Add CT_FindRelativePath and use for GCC configure

---
 scripts/build/cc/100-gcc.sh |  7 +++--
 scripts/functions           | 62 +++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 67 insertions(+), 2 deletions(-)

diff --git a/scripts/build/cc/100-gcc.sh b/scripts/build/cc/100-gcc.sh
index 7204b99..1c218de 100644
--- a/scripts/build/cc/100-gcc.sh
+++ b/scripts/build/cc/100-gcc.sh
@@ -413,6 +413,7 @@ do_gcc_core_backend() {
 
     CT_DoLog DEBUG "Extra config passed: '${extra_config[*]}'"
 
+    local relpath="$(CT_FindRelativePath "${PWD}" "${CT_SRC_DIR}/gcc-${CT_CC_GCC_VERSION}")"
     # Use --with-local-prefix so older gccs don't look in /usr/local (http://gcc.gnu.org/PR10532)
     CT_DoExecLog CFG                                \
     CC_FOR_BUILD="${CT_BUILD}-gcc"                  \
@@ -420,7 +421,7 @@ do_gcc_core_backend() {
     CFLAGS="${cflags}"                              \
     CXXFLAGS="${cflags}"                            \
     LDFLAGS="${core_LDFLAGS[*]}"                    \
-    "${CT_SRC_DIR}/gcc-${CT_CC_GCC_VERSION}/configure"  \
+    "${relpath}/configure"                          \
         --build=${CT_BUILD}                         \
         --host=${host}                              \
         --target=${CT_TARGET}                       \
@@ -876,6 +877,8 @@ do_gcc_backend() {
 
     CT_DoLog DEBUG "Extra config passed: '${extra_config[*]}'"
 
+    local relpath="$(CT_FindRelativePath "${PWD}" "${CT_SRC_DIR}/gcc-${CT_CC_GCC_VERSION}")"
+
     CT_DoExecLog CFG                                \
     CC_FOR_BUILD="${CT_BUILD}-gcc"                  \
     CFLAGS_FOR_BUILD="${CT_EXTRA_CFLAGS_FOR_BUILD-${cflags}}" \
@@ -885,7 +888,7 @@ do_gcc_backend() {
     CFLAGS_FOR_TARGET="${CT_TARGET_CFLAGS}"         \
     CXXFLAGS_FOR_TARGET="${CT_TARGET_CFLAGS}"       \
     LDFLAGS_FOR_TARGET="${CT_TARGET_LDFLAGS}"       \
-    "${CT_SRC_DIR}/gcc-${CT_CC_GCC_VERSION}/configure"  \
+    "${relpath}/configure"                          \
         --build=${CT_BUILD}                         \
         --host=${host}                              \
         --target=${CT_TARGET}                       \
diff --git a/scripts/functions b/scripts/functions
index c376a4f..529ebcc 100644
--- a/scripts/functions
+++ b/scripts/functions
@@ -1395,3 +1395,65 @@ CT_DoLoadState(){
     exec >>"${tmp_log_file}"
     rm -f "${state_dir}/tail.log"
 }
+
+# Based on https://github.com/Offirmo/offirmo-shell-lib/blob/master/bin/osl_lib_file.sh
+# .. modified to work with Dash.
+
+# both $1 and $2 are absolute paths beginning with /
+# returns relative path to $2/$target from $1/$source
+CT_FindRelativePath()
+{
+    local source=$1
+    local target=$2
+
+    #echo "source : \"$source\""
+    #echo "target : \"$target\""
+    return_value="OSL_FILE_compute_relative_path ERROR"
+
+    local common_part=$source # for now
+
+    local result=""
+
+    #echo "common_part is now : \"$common_part\""
+    #echo "result is now      : \"$result\""
+    #echo "target#common_part : \"${target#$common_part}\""
+    while [ "${target#$common_part}" = "${target}" ]; do
+        # no match, means that candidate common part is not correct
+        # go up one level (reduce common part)
+        common_part="$(dirname $common_part)"
+        # and record that we went back
+        if [ -z "${result}" ]; then
+            result=".."
+        else
+            result="../$result"
+        fi
+        #echo "common_part is now : \"$common_part\""
+        #echo "result is now      : \"$result\""
+        #echo "target#common_part : \"${target#$common_part}\""
+    done
+
+    #echo "common_part is     : \"$common_part\""
+
+    if [ "${common_part}" = "/" ]; then
+        # special case for root (no common path)
+        result="$result/"
+    fi
+
+    # since we now have identified the common part,
+    # compute the non-common part
+    forward_part="${target#$common_part}"
+    #echo "forward_part = \"$forward_part\""
+
+    if [ -n "${result}" -a -n "${forward_part}" ]; then
+        #echo "(simple concat)"
+        result="$result$forward_part"
+    elif [ -n "${forward_part}" ]; then
+        #echo "(concat with slash removal)"
+        result=$(echo $forward_part | awk '{ string=substr($0, 2, length($0)); print string; }' )
+    fi
+    #echo "result = \"$result\""
+    #return_value=$result
+    echo $result
+
+    return 0
+}
-- 
1.8.5.3

