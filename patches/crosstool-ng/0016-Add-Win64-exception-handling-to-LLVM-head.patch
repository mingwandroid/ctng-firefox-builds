From a602a16300b3b4a48dc496c4fb67d4302ecd9992 Mon Sep 17 00:00:00 2001
From: Ray Donnelly <mingw.android@gmail.com>
Date: Tue, 17 Dec 2013 14:16:36 +0000
Subject: [PATCH 16/24] Add Win64 exception handling to LLVM head

Also apply it to X86MCAsmInfoGNUCOFF too, not just MS.
.. and emit reg. names not numbers for SEH in MCAsmStreamer since
gas doesn't like numbers.
---
 .../head/160-Add-Win64-exception-handling.patch    | 426 +++++++++++++++++++++
 ...-Use-SEH-for-Win64-in-X86MCAsmInfoGNUCOFF.patch |  36 ++
 ...0-Emit-reg-names-for-SEH-in-MCAsmStreamer.patch |  57 +++
 3 files changed, 519 insertions(+)
 create mode 100644 patches/llvm/head/160-Add-Win64-exception-handling.patch
 create mode 100644 patches/llvm/head/170-Use-SEH-for-Win64-in-X86MCAsmInfoGNUCOFF.patch
 create mode 100644 patches/llvm/head/180-Emit-reg-names-for-SEH-in-MCAsmStreamer.patch

diff --git a/patches/llvm/head/160-Add-Win64-exception-handling.patch b/patches/llvm/head/160-Add-Win64-exception-handling.patch
new file mode 100644
index 0000000..b5327c7
--- /dev/null
+++ b/patches/llvm/head/160-Add-Win64-exception-handling.patch
@@ -0,0 +1,426 @@
+From 9dc2e7a953ca9ca7d86bfcee93923ec3382d2896 Mon Sep 17 00:00:00 2001
+From: Ray Donnelly <mingw.android@gmail.com>
+Date: Tue, 17 Dec 2013 14:07:18 +0000
+Subject: [PATCH] Add Win64 exception handling.
+
+Source Url: http://lists.cs.uiuc.edu/pipermail/llvm-commits/Week-of-Mon-20131216/198988.html
+
+From: kai <kai at redstar.de>
+Date: Wed, 29 May 2013 07:10:59 +0200
+Subject: [PATCH] Add Win64 exception handling.
+
+This patch enables Dwarf exception handling on Windows 64 based on the
+structured exception handling (SEH) mechanism built into the OS. This
+is similar to the way exception handling is implemented in gcc 4.8
+(mingw64) on Windows 64.
+
+For each instruction in the frame setup range, the needed unwind
+information is emitted. In order to match the gcc implementation, the
+personality function is emitted as handler function and the Dwarf code
+is emitted as handler data.
+
+Most of this patch is based on work by Charles Davis.
+---
+ lib/CodeGen/AsmPrinter/Win64Exception.cpp        |  12 +--
+ lib/MC/MCObjectFileInfo.cpp                      |  15 ++-
+ lib/Target/X86/MCTargetDesc/X86MCAsmInfo.cpp     |   7 +-
+ lib/Target/X86/MCTargetDesc/X86MCAsmInfo.cpp.rej |  12 +++
+ lib/Target/X86/X86AsmPrinter.h                   |   2 +
+ lib/Target/X86/X86ISelLowering.cpp               |   3 +-
+ lib/Target/X86/X86MCInstLower.cpp                | 100 ++++++++++++++++++
+ test/CodeGen/X86/avx-win64-args.ll               |   2 +
+ test/CodeGen/X86/win64_eh.ll                     | 125 +++++++++++++++++++++++
+ 9 files changed, 262 insertions(+), 16 deletions(-)
+ create mode 100644 lib/Target/X86/MCTargetDesc/X86MCAsmInfo.cpp.rej
+ create mode 100644 test/CodeGen/X86/win64_eh.ll
+
+diff --git a/lib/CodeGen/AsmPrinter/Win64Exception.cpp b/lib/CodeGen/AsmPrinter/Win64Exception.cpp
+index 422b0fd..2bd1a4e 100644
+--- a/lib/CodeGen/AsmPrinter/Win64Exception.cpp
++++ b/lib/CodeGen/AsmPrinter/Win64Exception.cpp
+@@ -78,9 +78,9 @@ void Win64Exception::beginFunction(const MachineFunction *MF) {
+   if (!shouldEmitPersonality)
+     return;
+ 
+-  MCSymbol *GCCHandlerSym =
+-    Asm->GetExternalSymbolSymbol("_GCC_specific_handler");
+-  Asm->OutStreamer.EmitWin64EHHandler(GCCHandlerSym, true, true);
++  const MCSymbol *PersHandlerSym = TLOF.getCFIPersonalitySymbol(Per, Asm->Mang,
++                                                                MMI);
++  Asm->OutStreamer.EmitWin64EHHandler(PersHandlerSym, true, true);
+ 
+   Asm->OutStreamer.EmitLabel(Asm->GetTempSymbol("eh_func_begin",
+                                                 Asm->getFunctionNumber()));
+@@ -99,14 +99,8 @@ void Win64Exception::endFunction(const MachineFunction *) {
+   MMI->TidyLandingPads();
+ 
+   if (shouldEmitPersonality) {
+-    const TargetLoweringObjectFile &TLOF = Asm->getObjFileLowering();
+-    const Function *Per = MMI->getPersonalities()[MMI->getPersonalityIndex()];
+-    const MCSymbol *Sym = TLOF.getCFIPersonalitySymbol(Per, Asm->Mang, MMI);
+-
+     Asm->OutStreamer.PushSection();
+     Asm->OutStreamer.EmitWin64EHHandlerData();
+-    Asm->OutStreamer.EmitValue(MCSymbolRefExpr::Create(Sym, Asm->OutContext),
+-                               4);
+     EmitExceptionTable();
+     Asm->OutStreamer.PopSection();
+   }
+diff --git a/lib/MC/MCObjectFileInfo.cpp b/lib/MC/MCObjectFileInfo.cpp
+index da70728..502bcc1 100644
+--- a/lib/MC/MCObjectFileInfo.cpp
++++ b/lib/MC/MCObjectFileInfo.cpp
+@@ -575,11 +575,16 @@ void MCObjectFileInfo::InitCOFFMCObjectFileInfo(Triple T) {
+   // though it contains relocatable pointers.  In PIC mode, this is probably a
+   // big runtime hit for C++ apps.  Either the contents of the LSDA need to be
+   // adjusted or this should be a data section.
+-  LSDASection =
+-    Ctx->getCOFFSection(".gcc_except_table",
+-                        COFF::IMAGE_SCN_CNT_INITIALIZED_DATA |
+-                        COFF::IMAGE_SCN_MEM_READ,
+-                        SectionKind::getReadOnly());
++  if (T.getOS() == Triple::Win32) {
++    // On Windows with SEH, the LSDA is emitted into the .xdata section
++    LSDASection = 0;
++  } else {
++    LSDASection =
++      Ctx->getCOFFSection(".gcc_except_table",
++                          COFF::IMAGE_SCN_CNT_INITIALIZED_DATA |
++                          COFF::IMAGE_SCN_MEM_READ,
++                          SectionKind::getReadOnly());
++  }
+ 
+   // Debug info.
+   DwarfAbbrevSection =
+diff --git a/lib/Target/X86/MCTargetDesc/X86MCAsmInfo.cpp b/lib/Target/X86/MCTargetDesc/X86MCAsmInfo.cpp
+index 93c4e3f..096c3d3 100644
+--- a/lib/Target/X86/MCTargetDesc/X86MCAsmInfo.cpp
++++ b/lib/Target/X86/MCTargetDesc/X86MCAsmInfo.cpp
+@@ -131,7 +131,8 @@ getNonexecutableStackSection(MCContext &Ctx) const {
+ void X86MCAsmInfoMicrosoft::anchor() { }
+ 
+ X86MCAsmInfoMicrosoft::X86MCAsmInfoMicrosoft(const Triple &Triple) {
+-  if (Triple.getArch() == Triple::x86_64) {
++  bool is64Bit = Triple.getArch() == Triple::x86_64;
++  if (is64Bit) {
+     GlobalPrefix = '\0';
+     PrivateGlobalPrefix = ".L";
+     HasMicrosoftFastStdCallMangling = false;
+@@ -142,6 +143,10 @@ X86MCAsmInfoMicrosoft::X86MCAsmInfoMicrosoft(const Triple &Triple) {
+   TextAlignFillValue = 0x90;
+ 
+   AllowAtInName = true;
++
++  // Exceptions handling
++  if (is64Bit)
++    ExceptionsType = ExceptionHandling::Win64;
+ }
+ 
+ void X86MCAsmInfoGNUCOFF::anchor() { }
+diff --git a/lib/Target/X86/MCTargetDesc/X86MCAsmInfo.cpp.rej b/lib/Target/X86/MCTargetDesc/X86MCAsmInfo.cpp.rej
+new file mode 100644
+index 0000000..542f7bf
+--- /dev/null
++++ b/lib/Target/X86/MCTargetDesc/X86MCAsmInfo.cpp.rej
+@@ -0,0 +1,12 @@
++--- lib/Target/X86/MCTargetDesc/X86MCAsmInfo.cpp
+++++ lib/Target/X86/MCTargetDesc/X86MCAsmInfo.cpp
++@@ -127,7 +127,8 @@
++ void X86MCAsmInfoMicrosoft::anchor() { }
++ 
++ X86MCAsmInfoMicrosoft::X86MCAsmInfoMicrosoft(const Triple &Triple) {
++-  if (Triple.getArch() == Triple::x86_64) {
+++  bool is64Bit = Triple.getArch() == Triple::x86_64;
+++  if (is64Bit) {
++     GlobalPrefix = "";
++     PrivateGlobalPrefix = ".L";
++   }
+diff --git a/lib/Target/X86/X86AsmPrinter.h b/lib/Target/X86/X86AsmPrinter.h
+index cf47dc4..106cf0b 100644
+--- a/lib/Target/X86/X86AsmPrinter.h
++++ b/lib/Target/X86/X86AsmPrinter.h
+@@ -27,6 +27,8 @@ class LLVM_LIBRARY_VISIBILITY X86AsmPrinter : public AsmPrinter {
+   const X86Subtarget *Subtarget;
+   StackMaps SM;
+ 
++  void EmitUnwindingInstruction(const MachineInstr *MI);
++
+  public:
+   explicit X86AsmPrinter(TargetMachine &TM, MCStreamer &Streamer)
+     : AsmPrinter(TM, Streamer), SM(*this) {
+diff --git a/lib/Target/X86/X86ISelLowering.cpp b/lib/Target/X86/X86ISelLowering.cpp
+index 3be3bf5..97cba82 100644
+--- a/lib/Target/X86/X86ISelLowering.cpp
++++ b/lib/Target/X86/X86ISelLowering.cpp
+@@ -596,7 +596,8 @@ void X86TargetLowering::resetOperationActions() {
+   // FIXME - use subtarget debug flags
+   if (!Subtarget->isTargetDarwin() &&
+       !Subtarget->isTargetELF() &&
+-      !Subtarget->isTargetCygMing()) {
++      !Subtarget->isTargetCygMing() &&
++      !Subtarget->isTargetWin64()) {
+     setOperationAction(ISD::EH_LABEL, MVT::Other, Expand);
+   }
+ 
+diff --git a/lib/Target/X86/X86MCInstLower.cpp b/lib/Target/X86/X86MCInstLower.cpp
+index 78d45e8..da648d0 100644
+--- a/lib/Target/X86/X86MCInstLower.cpp
++++ b/lib/Target/X86/X86MCInstLower.cpp
+@@ -776,7 +776,100 @@ static void LowerPATCHPOINT(MCStreamer &OS, StackMaps &SM,
+   EmitNops(OS, NumBytes - EncodedBytes, Is64Bit);
+ }
+ 
++static bool isCalleeSavedReg(const MachineFunction *MF,
++                             const TargetRegisterInfo *RI, unsigned Reg) {
++  const uint16_t *NVRegs = RI->getCalleeSavedRegs(MF);
++  while (*NVRegs) {
++    if (*NVRegs == Reg)
++      return true;
++    NVRegs++;
++  }
++  return false;
++}
++
++void X86AsmPrinter::EmitUnwindingInstruction(const MachineInstr *MI) {
++  assert(MI->getFlag(MachineInstr::FrameSetup) &&
++         "Only call frame setup instructions allowed here!");
++  unsigned SReg, DReg;
++  unsigned Offset;
++  const X86RegisterInfo *RI =
++    static_cast<const X86RegisterInfo *>(TM.getRegisterInfo());
++  switch (MI->getOpcode()) {
++  default: llvm_unreachable("Unknown frame setup opcode!");
++  case X86::PUSH64r:
++    SReg = MI->getOperand(0).getReg();
++    if (isCalleeSavedReg(MI->getParent()->getParent(), RI, SReg))
++      OutStreamer.EmitWin64EHPushReg(RI->getSEHRegNum(SReg));
++    else
++      OutStreamer.EmitWin64EHAllocStack(8);
++    break;
++  case X86::SUB64ri8:
++  case X86::SUB64ri32: {
++    DReg = MI->getOperand(0).getReg();
++    Offset = MI->getOperand(2).getImm();
++    if (DReg == RI->getStackRegister()) {
++      OutStreamer.EmitWin64EHAllocStack(Offset);
++    }
++  } break;
++  case X86::MOV64rr:
++    DReg = MI->getOperand(0).getReg();
++    SReg = MI->getOperand(1).getReg();
++    if (DReg == RI->getFrameRegister(*MF) && SReg == RI->getStackRegister())
++      OutStreamer.EmitWin64EHSetFrame(RI->getSEHRegNum(DReg), 0);
++    break;
++  case X86::MOV64mr:
++  case X86::MOVAPSmr:
++    DReg = MI->getOperand(0).getReg();
++    Offset = MI->getOperand(0).getOffset();
++    SReg = MI->getOperand(1).getReg();
++    if (DReg == RI->getFrameRegister(*MF) || DReg == RI->getStackRegister()) {
++      if (MI->getOpcode() == X86::MOVAPSmr)
++        OutStreamer.EmitWin64EHSaveXMM(RI->getSEHRegNum(SReg), Offset);
++      else
++        OutStreamer.EmitWin64EHSaveReg(RI->getSEHRegNum(SReg), Offset);
++    }
++    break;
++  case X86::MOV64ri:
++    // Occurs before alloca()/call to __chkstk
++    assert((MI->getNextNode()
++            && MI->getNextNode()->getOpcode() == X86::W64ALLOCA
++            && MI->getOperand(0).getReg() == X86::RAX)
++           && "X86::MOV64ri only allowed before X86::W64ALLOCA");
++    break;
++  case X86::W64ALLOCA:
++    // Occurs if alloca()/call to __chkstk is used. Do nothing.
++    break;
++  case X86::SUB64rr:
++    // Occurs after alloca()/call to __chkstk
++    assert((MI->getPrevNode()
++            && MI->getPrevNode()->getOpcode() == X86::W64ALLOCA
++            && MI->getOperand(0).getReg() == RI->getStackRegister()
++            && MI->getOperand(2).getReg() == X86::RAX)
++           && "X86::SUB64rr only allowed after X86::W64ALLOCA");
++    break;
++  }
++  // Prolog ends if next instruction does not have the FrameSetup flag
++  // and is not the PROLOG_LABEL.
++  if (MI->getNextNode()) {
++    const MachineInstr *MI2 = MI->getNextNode();
++    if (!(MI2->getFlag(MachineInstr::FrameSetup) ||
++          (MI2->isPrologLabel() && MI2->getNextNode() &&
++           MI2->getNextNode()->getFlag(MachineInstr::FrameSetup)))) {
++      OutStreamer.EmitWin64EHEndProlog();
++    }
++  }
++}
++
+ void X86AsmPrinter::EmitInstruction(const MachineInstr *MI) {
++  // Emit end of prolog for Win64-style EH if there is no framesetup.
++  if (MAI->getExceptionHandlingType() == ExceptionHandling::Win64 &&
++      !MI->getFlag(MachineInstr::FrameSetup) &&
++      MI->getParent()->getParent()->getFunction()->needsUnwindTableEntry() &&
++      MI == MI->getParent()->instr_begin() &&
++      MI->getParent()->getNumber() == 0) {
++    OutStreamer.EmitWin64EHEndProlog();
++  }
++
+   X86MCInstLower MCInstLowering(*MF, *this);
+   switch (MI->getOpcode()) {
+   case TargetOpcode::DBG_VALUE:
+@@ -888,4 +981,11 @@ void X86AsmPrinter::EmitInstruction(const MachineInstr *MI) {
+   MCInst TmpInst;
+   MCInstLowering.Lower(MI, TmpInst);
+   OutStreamer.EmitInstruction(TmpInst);
++
++  // Emit SEH unwind info for Win64-style EH.
++  if (MAI->getExceptionHandlingType() == ExceptionHandling::Win64 &&
++      MI->getFlag(MachineInstr::FrameSetup) &&
++      MI->getParent()->getParent()->getFunction()->needsUnwindTableEntry()) {
++    EmitUnwindingInstruction(MI);
++  }
+ }
+diff --git a/test/CodeGen/X86/avx-win64-args.ll b/test/CodeGen/X86/avx-win64-args.ll
+index 85b2634..3b2f3d4 100644
+--- a/test/CodeGen/X86/avx-win64-args.ll
++++ b/test/CodeGen/X86/avx-win64-args.ll
+@@ -1,4 +1,6 @@
+ ; RUN: llc < %s -mcpu=corei7-avx -mattr=+avx | FileCheck %s
++; XFAIL: *
++; See PR16779.
+ target triple = "x86_64-pc-win32"
+ 
+ declare <8 x float> @foo(<8 x float>, i32)
+diff --git a/test/CodeGen/X86/win64_eh.ll b/test/CodeGen/X86/win64_eh.ll
+new file mode 100644
+index 0000000..4bc1dc2
+--- /dev/null
++++ b/test/CodeGen/X86/win64_eh.ll
+@@ -0,0 +1,125 @@
++; RUN: llc < %s -O0 -mtriple=x86_64-pc-win32 | FileCheck %s
++
++; Check function with nor prolog
++define void @foo0() uwtable {
++entry:
++  ret void
++}
++; CHECK: .seh_proc foo0
++; CHECK: .seh_endprologue
++; CHECK: ret
++; CHECK: .seh_endproc
++
++; Checks a small stack allocation
++define void @foo1() uwtable {
++entry:
++  %baz = alloca [2000 x i16], align 2
++  ret void
++}
++; CHECK: .seh_proc foo1
++; CHECK: subq $4000, %rsp
++; CHECK: .seh_stackalloc 4000
++; CHECK: .seh_endprologue
++; CHECK: ret
++; CHECK: .seh_endproc
++
++
++; Checks a stack allocation requiring call to __chkstk
++define void @foo2() uwtable {
++entry:
++  %baz = alloca [4000 x i16], align 2
++  ret void
++}
++; CHECK: .seh_proc foo2
++; CHECK: movabsq $8000, %rax
++; CHECK: callq __chkstk
++; CHECK: subq %rax, %rsp
++; CHECK: .seh_endprologue
++; CHECK: ret
++; CHECK: .seh_endproc
++
++
++; Checks stack push
++define i32 @foo3(i32 %f_arg, i32 %e_arg, i32 %d_arg, i32 %c_arg, i32 %b_arg, i32 %a_arg) uwtable {
++entry:
++  %a = alloca i32
++  %b = alloca i32
++  %c = alloca i32
++  %d = alloca i32
++  %e = alloca i32
++  %f = alloca i32
++  store i32 %a_arg, i32* %a
++  store i32 %b_arg, i32* %b
++  store i32 %c_arg, i32* %c
++  store i32 %d_arg, i32* %d
++  store i32 %e_arg, i32* %e
++  store i32 %f_arg, i32* %f
++  %tmp = load i32* %a
++  %tmp1 = mul i32 %tmp, 2
++  %tmp2 = load i32* %b
++  %tmp3 = mul i32 %tmp2, 3
++  %tmp4 = add i32 %tmp1, %tmp3
++  %tmp5 = load i32* %c
++  %tmp6 = mul i32 %tmp5, 5
++  %tmp7 = add i32 %tmp4, %tmp6
++  %tmp8 = load i32* %d
++  %tmp9 = mul i32 %tmp8, 7
++  %tmp10 = add i32 %tmp7, %tmp9
++  %tmp11 = load i32* %e
++  %tmp12 = mul i32 %tmp11, 11
++  %tmp13 = add i32 %tmp10, %tmp12
++  %tmp14 = load i32* %f
++  %tmp15 = mul i32 %tmp14, 13
++  %tmp16 = add i32 %tmp13, %tmp15
++  ret i32 %tmp16
++}
++; CHECK: .seh_proc foo3
++; CHECK: pushq %rsi
++; CHECK: .seh_pushreg 6
++; CHECK: subq $24, %rsp
++; CHECK: .seh_stackalloc 24
++; CHECK: .seh_endprologue
++; CHECK: ret
++; CHECK: .seh_endproc
++
++
++; Check emission of eh handler and handler data
++declare i32 @_d_eh_personality(i32, i32, i64, i8*, i8*)
++declare void @_d_eh_resume_unwind(i8*)
++
++declare i32 @bar()
++
++define i32 @foo4() #0 {
++entry:
++  %step = alloca i32, align 4
++  store i32 0, i32* %step
++  %tmp = load i32* %step
++
++  %tmp1 = invoke i32 @bar()
++          to label %finally unwind label %landingpad
++
++finally:
++  store i32 1, i32* %step
++  br label %endtryfinally
++
++landingpad:
++  %landing_pad = landingpad { i8*, i32 } personality i32 (i32, i32, i64, i8*, i8*)* @_d_eh_personality
++          cleanup
++  %tmp3 = extractvalue { i8*, i32 } %landing_pad, 0
++  store i32 2, i32* %step
++  call void @_d_eh_resume_unwind(i8* %tmp3)
++  unreachable
++
++endtryfinally:
++  %tmp10 = load i32* %step
++  ret i32 %tmp10
++}
++
++; CHECK: .seh_proc foo4
++; CHECK: .seh_handler _d_eh_personality, @unwind, @except
++; CHECK: subq $56, %rsp
++; CHECK: .seh_stackalloc 56
++; CHECK: .seh_endprologue
++; CHECK: ret
++; CHECK: .seh_handlerdata
++; CHECK: .seh_endproc
+-- 
+1.8.5.1
+
diff --git a/patches/llvm/head/170-Use-SEH-for-Win64-in-X86MCAsmInfoGNUCOFF.patch b/patches/llvm/head/170-Use-SEH-for-Win64-in-X86MCAsmInfoGNUCOFF.patch
new file mode 100644
index 0000000..7a0a8d3
--- /dev/null
+++ b/patches/llvm/head/170-Use-SEH-for-Win64-in-X86MCAsmInfoGNUCOFF.patch
@@ -0,0 +1,36 @@
+From 8bcfa03ec1b51d758bf93c513201e36db7a9bb72 Mon Sep 17 00:00:00 2001
+From: Ray Donnelly <mingw.android@gmail.com>
+Date: Wed, 18 Dec 2013 02:23:51 +0000
+Subject: [PATCH 1/2] Use SEH for Win64 in X86MCAsmInfoGNUCOFF
+
+---
+ lib/Target/X86/MCTargetDesc/X86MCAsmInfo.cpp | 8 ++++++--
+ 1 file changed, 6 insertions(+), 2 deletions(-)
+
+diff --git a/lib/Target/X86/MCTargetDesc/X86MCAsmInfo.cpp b/lib/Target/X86/MCTargetDesc/X86MCAsmInfo.cpp
+index 93c4e3f..dde5613 100644
+--- a/lib/Target/X86/MCTargetDesc/X86MCAsmInfo.cpp
++++ b/lib/Target/X86/MCTargetDesc/X86MCAsmInfo.cpp
+@@ -147,7 +147,8 @@ X86MCAsmInfoMicrosoft::X86MCAsmInfoMicrosoft(const Triple &Triple) {
+ void X86MCAsmInfoGNUCOFF::anchor() { }
+ 
+ X86MCAsmInfoGNUCOFF::X86MCAsmInfoGNUCOFF(const Triple &Triple) {
+-  if (Triple.getArch() == Triple::x86_64) {
++  bool is64Bit = Triple.getArch() == Triple::x86_64;
++  if (is64Bit) {
+     GlobalPrefix = '\0';
+     PrivateGlobalPrefix = ".L";
+     HasMicrosoftFastStdCallMangling = false;
+@@ -158,5 +159,8 @@ X86MCAsmInfoGNUCOFF::X86MCAsmInfoGNUCOFF(const Triple &Triple) {
+   TextAlignFillValue = 0x90;
+ 
+   // Exceptions handling
+-  ExceptionsType = ExceptionHandling::DwarfCFI;
++  if (is64Bit)
++    ExceptionsType = ExceptionHandling::Win64;
++  else
++    ExceptionsType = ExceptionHandling::DwarfCFI;
+ }
+-- 
+1.8.5.1
+
diff --git a/patches/llvm/head/180-Emit-reg-names-for-SEH-in-MCAsmStreamer.patch b/patches/llvm/head/180-Emit-reg-names-for-SEH-in-MCAsmStreamer.patch
new file mode 100644
index 0000000..8a5a6c6
--- /dev/null
+++ b/patches/llvm/head/180-Emit-reg-names-for-SEH-in-MCAsmStreamer.patch
@@ -0,0 +1,57 @@
+From 167889effdd5a8870160b134e11b49407457380a Mon Sep 17 00:00:00 2001
+From: Ray Donnelly <mingw.android@gmail.com>
+Date: Wed, 18 Dec 2013 02:24:40 +0000
+Subject: [PATCH 2/2] Emit reg names for SEH in MCAsmStreamer
+
+---
+ lib/MC/MCAsmStreamer.cpp | 15 +++++++++++----
+ 1 file changed, 11 insertions(+), 4 deletions(-)
+
+diff --git a/lib/MC/MCAsmStreamer.cpp b/lib/MC/MCAsmStreamer.cpp
+index ca49f8f..5de19b38 100644
+--- a/lib/MC/MCAsmStreamer.cpp
++++ b/lib/MC/MCAsmStreamer.cpp
+@@ -1172,14 +1172,17 @@ void MCAsmStreamer::EmitWin64EHHandlerData() {
+ void MCAsmStreamer::EmitWin64EHPushReg(unsigned Register) {
+   MCStreamer::EmitWin64EHPushReg(Register);
+ 
+-  OS << "\t.seh_pushreg " << Register;
++  OS << "\t.seh_pushreg ";
++  EmitRegisterName(Register);
+   EmitEOL();
+ }
+ 
+ void MCAsmStreamer::EmitWin64EHSetFrame(unsigned Register, unsigned Offset) {
+   MCStreamer::EmitWin64EHSetFrame(Register, Offset);
+ 
+-  OS << "\t.seh_setframe " << Register << ", " << Offset;
++  OS << "\t.seh_setframe ";
++  EmitRegisterName(Register);
++  OS << ", " << Offset;
+   EmitEOL();
+ }
+ 
+@@ -1193,14 +1196,18 @@ void MCAsmStreamer::EmitWin64EHAllocStack(unsigned Size) {
+ void MCAsmStreamer::EmitWin64EHSaveReg(unsigned Register, unsigned Offset) {
+   MCStreamer::EmitWin64EHSaveReg(Register, Offset);
+ 
+-  OS << "\t.seh_savereg " << Register << ", " << Offset;
++  OS << "\t.seh_savereg ";
++  EmitRegisterName(Register);
++  OS << ", " << Offset;
+   EmitEOL();
+ }
+ 
+ void MCAsmStreamer::EmitWin64EHSaveXMM(unsigned Register, unsigned Offset) {
+   MCStreamer::EmitWin64EHSaveXMM(Register, Offset);
+ 
+-  OS << "\t.seh_savexmm " << Register << ", " << Offset;
++  OS << "\t.seh_savexmm ";
++  EmitRegisterName(Register);
++  OS << ", " << Offset;
+   EmitEOL();
+ }
+ 
+-- 
+1.8.5.1
+
-- 
1.8.5.2

