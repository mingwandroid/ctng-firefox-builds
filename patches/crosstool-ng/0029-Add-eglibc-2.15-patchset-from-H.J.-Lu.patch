From 7afc92be235298a70a4360222f01efb53afac0f2 Mon Sep 17 00:00:00 2001
From: Ray Donnelly <mingw.android@gmail.com>
Date: Fri, 31 Jan 2014 12:56:23 +0000
Subject: [PATCH 29/30] Add eglibc 2.15 patchset from H.J. Lu

.. Backport of BZ14117, shared headers for multilib
---
 ...-BZ14117-Add-byteswap-16.h-for-__bswap_16.patch |  414 ++++
 ...-bits-byteswap.h-for-both-i386-and-x86_64.patch |  508 +++++
 ...Use-x86_64-bits-mathdef.h-for-i386-x86_64.patch |  225 ++
 ...bits-pthreadtypes.h-semaphore.h-for-i386-.patch |  835 ++++++++
 ...-support-to-i386-sys-elf.h-and-sys-vm86.h.patch |   78 +
 .../005-BZ14117-Update-x86_64-bits-stat.h.patch    |   64 +
 ...6_64-bits-typesizes.h-for-i386-and-x86-64.patch |  111 +
 ...Use-i386-bits-wchar.h-for-i386-and-x86-64.patch |   87 +
 ...ne-DR_LEN_8-only-if-__x86_64__-is-defined.patch |   38 +
 ...86_64-bits-io-perm-.h-for-i386-and-x86_64.patch |  718 +++++++
 ...heck-__SSE_MATH__-in-x86_64-feraiseexcept.patch |   59 +
 ...h-and-C-namespace-to-i386-bits-mathinline.patch |  336 +++
 ...7-Disable-x87-inline-functions-for-x86-64.patch |  441 ++++
 ...386-bits-mathinline.h-for-i386-and-x86_64.patch | 2255 ++++++++++++++++++++
 ...e-__volatile__-to-access-fpu-control-word.patch |   56 +
 15 files changed, 6225 insertions(+)
 create mode 100644 patches/glibc/2.15/000-BZ14117-Add-byteswap-16.h-for-__bswap_16.patch
 create mode 100644 patches/glibc/2.15/001-BZ14117-Use-x86-64-bits-byteswap.h-for-both-i386-and-x86_64.patch
 create mode 100644 patches/glibc/2.15/002-BZ14117-Use-x86_64-bits-mathdef.h-for-i386-x86_64.patch
 create mode 100644 patches/glibc/2.15/003-BZ14117-Use-x86-64-bits-pthreadtypes.h-semaphore.h-for-i386-.patch
 create mode 100644 patches/glibc/2.15/004-BZ14117-Add-x86-64-support-to-i386-sys-elf.h-and-sys-vm86.h.patch
 create mode 100644 patches/glibc/2.15/005-BZ14117-Update-x86_64-bits-stat.h.patch
 create mode 100644 patches/glibc/2.15/006-BZ14117-Use-x86_64-bits-typesizes.h-for-i386-and-x86-64.patch
 create mode 100644 patches/glibc/2.15/007-BZ14117-Use-i386-bits-wchar.h-for-i386-and-x86-64.patch
 create mode 100644 patches/glibc/2.15/008-BZ14117-Define-DR_LEN_8-only-if-__x86_64__-is-defined.patch
 create mode 100644 patches/glibc/2.15/009-BZ14117-Use-x86_64-bits-io-perm-.h-for-i386-and-x86_64.patch
 create mode 100644 patches/glibc/2.15/010-BZ14117-Check-__SSE_MATH__-in-x86_64-feraiseexcept.patch
 create mode 100644 patches/glibc/2.15/011-BZ14117-Add-SSE-math-and-C-namespace-to-i386-bits-mathinline.patch
 create mode 100644 patches/glibc/2.15/012-BZ14117-Disable-x87-inline-functions-for-x86-64.patch
 create mode 100644 patches/glibc/2.15/013-BZ14117-Use-i386-bits-mathinline.h-for-i386-and-x86_64.patch
 create mode 100644 patches/glibc/2.15/014-BZ14117-Use-__volatile__-to-access-fpu-control-word.patch

diff --git a/patches/glibc/2.15/000-BZ14117-Add-byteswap-16.h-for-__bswap_16.patch b/patches/glibc/2.15/000-BZ14117-Add-byteswap-16.h-for-__bswap_16.patch
new file mode 100644
index 0000000..70c2a34
--- /dev/null
+++ b/patches/glibc/2.15/000-BZ14117-Add-byteswap-16.h-for-__bswap_16.patch
@@ -0,0 +1,414 @@
+From f8887d0a5feda97244613135822b0439addc2b1f Mon Sep 17 00:00:00 2001
+From: "H.J. Lu" <hjl.tools@gmail.com>
+Date: Fri, 6 Apr 2012 15:13:09 -0700
+Subject: [PATCH] Add byteswap-16.h for __bswap_16
+
+---
+ ChangeLog                         | 13 ++++++++
+ bits/byteswap-16.h                | 33 ++++++++++++++++++++
+ bits/byteswap.h                   | 13 ++------
+ string/Makefile                   |  4 +--
+ sysdeps/i386/bits/byteswap-16.h   | 49 +++++++++++++++++++++++++++++
+ sysdeps/i386/bits/byteswap.h      | 29 ++---------------
+ sysdeps/s390/bits/byteswap-16.h   | 65 +++++++++++++++++++++++++++++++++++++++
+ sysdeps/s390/bits/byteswap.h      | 42 ++-----------------------
+ sysdeps/x86_64/bits/byteswap-16.h | 49 +++++++++++++++++++++++++++++
+ sysdeps/x86_64/bits/byteswap.h    | 22 ++-----------
+ 10 files changed, 219 insertions(+), 100 deletions(-)
+ create mode 100644 bits/byteswap-16.h
+ create mode 100644 sysdeps/i386/bits/byteswap-16.h
+ create mode 100644 sysdeps/s390/bits/byteswap-16.h
+ create mode 100644 sysdeps/x86_64/bits/byteswap-16.h
+
+diff -urN a/ChangeLog b/ChangeLog
+--- a/ChangeLog	2012-01-01 12:16:32.000000000 +0000
++++ b/ChangeLog	2014-02-02 18:20:22.664675876 +0000
+@@ -1,3 +1,16 @@
++2012-04-06  H.J. Lu  <hongjiu.lu@intel.com>
++
++       * bits/byteswap.h (__bswap_16): Removed.
++       Include <bits/byteswap-16.h> to get __bswap_16.
++       * sysdeps/i386/bits/byteswap.h: Likewise.
++       * sysdeps/s390/bits/byteswap.h: Likewise.
++       * sysdeps/x86_64/bits/byteswap.h: Likewise.
++       * bits/byteswap-16.h: New file.
++       * sysdeps/i386/bits/byteswap-16.h: Likewise.
++       * sysdeps/s390/bits/byteswap-16.h: Likewise.
++       * sysdeps/x86_64/bits/byteswap-16.h: Likewise.
++       * string/Makefile (headers): Add bits/byteswap-16.h.
++
+ 2012-01-01  Ulrich Drepper  <drepper@gmail.com>
+ 
+ 	* posix/getconf.c: Update copyright year.
+diff -urN a/bits/byteswap-16.h b/bits/byteswap-16.h
+--- a/bits/byteswap-16.h	1970-01-01 01:00:00.000000000 +0100
++++ b/bits/byteswap-16.h	2014-02-02 18:19:31.937224729 +0000
+@@ -0,0 +1,33 @@
++/* Macros to swap the order of bytes in 16-bit integer values.
++   Copyright (C) 2012 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <http://www.gnu.org/licenses/>.  */
++
++#ifndef _BITS_BYTESWAP_H
++# error "Never use <bits/byteswap-16.h> directly; include <byteswap.h> instead."
++#endif
++
++#ifdef __GNUC__
++# define __bswap_16(x) \
++    (__extension__							      \
++     ({ unsigned short int __bsx = (x); __bswap_constant_16 (__bsx); }))
++#else
++static __inline unsigned short int
++__bswap_16 (unsigned short int __bsx)
++{
++  return __bswap_constant_16 (__bsx);
++}
++#endif
+diff -urN a/bits/byteswap.h b/bits/byteswap.h
+--- a/bits/byteswap.h	2012-01-01 12:16:32.000000000 +0000
++++ b/bits/byteswap.h	2014-02-02 18:19:31.937224729 +0000
+@@ -29,17 +29,8 @@
+ #define __bswap_constant_16(x) \
+      ((((x) >> 8) & 0xffu) | (((x) & 0xffu) << 8))
+ 
+-#ifdef __GNUC__
+-# define __bswap_16(x) \
+-    (__extension__							      \
+-     ({ unsigned short int __bsx = (x); __bswap_constant_16 (__bsx); }))
+-#else
+-static __inline unsigned short int
+-__bswap_16 (unsigned short int __bsx)
+-{
+-  return __bswap_constant_16 (__bsx);
+-}
+-#endif
++/* Get __bswap_16.  */
++#include <bits/byteswap-16.h>
+ 
+ /* Swap bytes in 32 bit value.  */
+ #define __bswap_constant_32(x) \
+diff -urN a/string/Makefile b/string/Makefile
+--- a/string/Makefile	2012-01-01 12:16:32.000000000 +0000
++++ b/string/Makefile	2014-02-02 18:19:31.937224729 +0000
+@@ -22,8 +22,8 @@
+ subdir	:= string
+ 
+ headers	:= string.h strings.h memory.h endian.h bits/endian.h \
+-	   argz.h envz.h byteswap.h bits/byteswap.h bits/string.h \
+-	   bits/string2.h bits/string3.h
++	   argz.h envz.h byteswap.h bits/byteswap.h bits/byteswap-16.h \
++	   bits/string.h bits/string2.h bits/string3.h
+ 
+ routines	:= strcat strchr strcmp strcoll strcpy strcspn		\
+ 		   strverscmp strdup strndup				\
+diff -urN a/sysdeps/i386/bits/byteswap-16.h b/sysdeps/i386/bits/byteswap-16.h
+--- a/sysdeps/i386/bits/byteswap-16.h	1970-01-01 01:00:00.000000000 +0100
++++ b/sysdeps/i386/bits/byteswap-16.h	2014-02-02 18:19:31.937224729 +0000
+@@ -0,0 +1,49 @@
++/* Macros to swap the order of bytes in 16-bit integer values.
++   Copyright (C) 2012 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <http://www.gnu.org/licenses/>.  */
++
++#ifndef _BITS_BYTESWAP_H
++# error "Never use <bits/byteswap-16.h> directly; include <byteswap.h> instead."
++#endif
++
++#ifdef __GNUC__
++# if __GNUC__ >= 2
++#  define __bswap_16(x) \
++     (__extension__							      \
++      ({ register unsigned short int __v, __x = (unsigned short int) (x);     \
++	 if (__builtin_constant_p (__x))				      \
++	   __v = __bswap_constant_16 (__x);				      \
++	 else								      \
++	   __asm__ ("rorw $8, %w0"					      \
++		    : "=r" (__v)					      \
++		    : "0" (__x)						      \
++		    : "cc");						      \
++	 __v; }))
++# else
++/* This is better than nothing.  */
++#  define __bswap_16(x) \
++     (__extension__							      \
++      ({ register unsigned short int __x = (unsigned short int) (x);	      \
++	 __bswap_constant_16 (__x); }))
++# endif
++#else
++static __inline unsigned short int
++__bswap_16 (unsigned short int __bsx)
++{
++  return __bswap_constant_16 (__bsx);
++}
++#endif
+diff -urN a/sysdeps/i386/bits/byteswap.h b/sysdeps/i386/bits/byteswap.h
+--- a/sysdeps/i386/bits/byteswap.h	2012-01-01 12:16:32.000000000 +0000
++++ b/sysdeps/i386/bits/byteswap.h	2014-02-02 18:19:31.937224729 +0000
+@@ -29,33 +29,8 @@
+ #define __bswap_constant_16(x) \
+      ((unsigned short int) ((((x) >> 8) & 0xff) | (((x) & 0xff) << 8)))
+ 
+-#ifdef __GNUC__
+-# if __GNUC__ >= 2
+-#  define __bswap_16(x) \
+-     (__extension__							      \
+-      ({ register unsigned short int __v, __x = (unsigned short int) (x);     \
+-	 if (__builtin_constant_p (__x))				      \
+-	   __v = __bswap_constant_16 (__x);				      \
+-	 else								      \
+-	   __asm__ ("rorw $8, %w0"					      \
+-		    : "=r" (__v)					      \
+-		    : "0" (__x)						      \
+-		    : "cc");						      \
+-	 __v; }))
+-# else
+-/* This is better than nothing.  */
+-#  define __bswap_16(x) \
+-     (__extension__							      \
+-      ({ register unsigned short int __x = (unsigned short int) (x);	      \
+-	 __bswap_constant_16 (__x); }))
+-# endif
+-#else
+-static __inline unsigned short int
+-__bswap_16 (unsigned short int __bsx)
+-{
+-  return __bswap_constant_16 (__bsx);
+-}
+-#endif
++/* Get __bswap_16.  */
++#include <bits/byteswap-16.h>
+ 
+ /* Swap bytes in 32 bit value.  */
+ #define __bswap_constant_32(x) \
+diff -urN a/sysdeps/s390/bits/byteswap-16.h b/sysdeps/s390/bits/byteswap-16.h
+--- a/sysdeps/s390/bits/byteswap-16.h	1970-01-01 01:00:00.000000000 +0100
++++ b/sysdeps/s390/bits/byteswap-16.h	2014-02-02 18:19:31.940558066 +0000
+@@ -0,0 +1,65 @@
++/* Macros to swap the order of bytes in 16-bit integer values.  s390 version
++   Copyright (C) 2012 Free Software Foundation, Inc.
++   Contributed by Martin Schwidefsky (schwidefsky@de.ibm.com).
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <http://www.gnu.org/licenses/>.  */
++
++#ifndef _BITS_BYTESWAP_H
++# error "Never use <bits/byteswap-16.h> directly; include <byteswap.h> instead."
++#endif
++
++#include <bits/wordsize.h>
++
++/* Swap bytes in 16 bit value. */
++#if defined __GNUC__ && __GNUC__ >= 2
++# if __WORDSIZE == 64
++#  define __bswap_16(x) \
++     (__extension__							      \
++      ({ unsigned short int __v, __x = (x);				      \
++	 if (__builtin_constant_p (x))					      \
++	   __v = __bswap_constant_16 (__x);				      \
++	 else {								      \
++	   unsigned short int __tmp = (unsigned short int) (__x);             \
++	   __asm__ __volatile__ (                                             \
++	      "lrvh %0,%1"                                                    \
++	      : "=&d" (__v) : "m" (__tmp) );                                  \
++	 }                                                                    \
++	 __v; }))
++# else
++#  define __bswap_16(x) \
++     (__extension__							      \
++      ({ unsigned short int __v, __x = (x);				      \
++	 if (__builtin_constant_p (x))					      \
++	   __v = __bswap_constant_16 (__x);				      \
++	 else {								      \
++	   unsigned short int __tmp = (unsigned short int) (__x);             \
++	   __asm__ __volatile__ (                                             \
++	      "sr   %0,%0\n"                                                  \
++	      "la   1,%1\n"                                                   \
++	      "icm  %0,2,1(1)\n"                                              \
++	      "ic   %0,0(1)"                                                  \
++	      : "=&d" (__v) : "m" (__tmp) : "1");                             \
++	 }                                                                    \
++	 __v; }))
++# endif
++#else
++/* This is better than nothing.  */
++static __inline unsigned short int
++__bswap_16 (unsigned short int __bsx)
++{
++  return __bswap_constant_16 (__bsx);
++}
++#endif
+diff -urN a/sysdeps/s390/bits/byteswap.h b/sysdeps/s390/bits/byteswap.h
+--- a/sysdeps/s390/bits/byteswap.h	2012-01-01 12:16:32.000000000 +0000
++++ b/sysdeps/s390/bits/byteswap.h	2014-02-02 18:19:31.940558066 +0000
+@@ -30,46 +30,8 @@
+ #define __bswap_constant_16(x) \
+      ((((x) >> 8) & 0xff) | (((x) & 0xff) << 8))
+ 
+-/* Swap bytes in 16 bit value. */
+-#if defined __GNUC__ && __GNUC__ >= 2
+-# if __WORDSIZE == 64
+-#  define __bswap_16(x) \
+-     (__extension__							      \
+-      ({ unsigned short int __v, __x = (x);				      \
+-	 if (__builtin_constant_p (x))					      \
+-	   __v = __bswap_constant_16 (__x);				      \
+-	 else {								      \
+-	   unsigned short int __tmp = (unsigned short int) (__x);             \
+-	   __asm__ __volatile__ (                                             \
+-	      "lrvh %0,%1"                                                    \
+-	      : "=&d" (__v) : "m" (__tmp) );                                  \
+-	 }                                                                    \
+-	 __v; }))
+-# else
+-#  define __bswap_16(x) \
+-     (__extension__							      \
+-      ({ unsigned short int __v, __x = (x);				      \
+-	 if (__builtin_constant_p (x))					      \
+-	   __v = __bswap_constant_16 (__x);				      \
+-	 else {								      \
+-	   unsigned short int __tmp = (unsigned short int) (__x);             \
+-	   __asm__ __volatile__ (                                             \
+-	      "sr   %0,%0\n"                                                  \
+-	      "la   1,%1\n"                                                   \
+-	      "icm  %0,2,1(1)\n"                                              \
+-	      "ic   %0,0(1)"                                                  \
+-	      : "=&d" (__v) : "m" (__tmp) : "1");                             \
+-	 }                                                                    \
+-	 __v; }))
+-# endif
+-#else
+-/* This is better than nothing.  */
+-static __inline unsigned short int
+-__bswap_16 (unsigned short int __bsx)
+-{
+-  return __bswap_constant_16 (__bsx);
+-}
+-#endif
++/* Get __bswap_16.  */
++#include <bits/byteswap-16.h>
+ 
+ /* Swap bytes in 32 bit value.  */
+ #define __bswap_constant_32(x) \
+diff -urN a/sysdeps/x86_64/bits/byteswap-16.h b/sysdeps/x86_64/bits/byteswap-16.h
+--- a/sysdeps/x86_64/bits/byteswap-16.h	1970-01-01 01:00:00.000000000 +0100
++++ b/sysdeps/x86_64/bits/byteswap-16.h	2014-02-02 18:19:31.940558066 +0000
+@@ -0,0 +1,49 @@
++/* Macros to swap the order of bytes in 16-bit integer values.
++   Copyright (C) 2012 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <http://www.gnu.org/licenses/>.  */
++
++#ifndef _BITS_BYTESWAP_H
++# error "Never use <bits/byteswap-16.h> directly; include <byteswap.h> instead."
++#endif
++
++#ifdef __GNUC__
++# if __GNUC__ >= 2
++#  define __bswap_16(x) \
++     (__extension__							      \
++      ({ register unsigned short int __v, __x = (unsigned short int) (x);     \
++	 if (__builtin_constant_p (__x))				      \
++	   __v = __bswap_constant_16 (__x);				      \
++	 else								      \
++	   __asm__ ("rorw $8, %w0"					      \
++		    : "=r" (__v)					      \
++		    : "0" (__x)						      \
++		    : "cc");						      \
++	 __v; }))
++# else
++/* This is better than nothing.  */
++#  define __bswap_16(x) \
++     (__extension__							      \
++      ({ register unsigned short int __x = (unsigned short int) (x);	      \
++	 __bswap_constant_16 (__x); }))
++# endif
++#else
++static __inline unsigned short int
++__bswap_16 (unsigned short int __bsx)
++{
++  return __bswap_constant_16 (__bsx);
++}
++#endif
+diff -urN a/sysdeps/x86_64/bits/byteswap.h b/sysdeps/x86_64/bits/byteswap.h
+--- a/sysdeps/x86_64/bits/byteswap.h	2012-01-01 12:16:32.000000000 +0000
++++ b/sysdeps/x86_64/bits/byteswap.h	2014-02-02 18:19:31.940558066 +0000
+@@ -31,26 +31,8 @@
+ #define __bswap_constant_16(x) \
+      ((unsigned short int) ((((x) >> 8) & 0xff) | (((x) & 0xff) << 8)))
+ 
+-#if defined __GNUC__ && __GNUC__ >= 2
+-# define __bswap_16(x) \
+-     (__extension__							      \
+-      ({ register unsigned short int __v, __x = (unsigned short int) (x);     \
+-	 if (__builtin_constant_p (__x))				      \
+-	   __v = __bswap_constant_16 (__x);				      \
+-	 else								      \
+-	   __asm__ ("rorw $8, %w0"					      \
+-		    : "=r" (__v)					      \
+-		    : "0" (__x)						      \
+-		    : "cc");						      \
+-	 __v; }))
+-#else
+-/* This is better than nothing.  */
+-# define __bswap_16(x) \
+-     (__extension__							      \
+-      ({ register unsigned short int __x = (unsigned short int) (x);          \
+-	 __bswap_constant_16 (__x); }))
+-#endif
+-
++/* Get __bswap_16.  */
++#include <bits/byteswap-16.h>
+ 
+ /* Swap bytes in 32 bit value.  */
+ #define __bswap_constant_32(x) \
diff --git a/patches/glibc/2.15/001-BZ14117-Use-x86-64-bits-byteswap.h-for-both-i386-and-x86_64.patch b/patches/glibc/2.15/001-BZ14117-Use-x86-64-bits-byteswap.h-for-both-i386-and-x86_64.patch
new file mode 100644
index 0000000..50b6957
--- /dev/null
+++ b/patches/glibc/2.15/001-BZ14117-Use-x86-64-bits-byteswap.h-for-both-i386-and-x86_64.patch
@@ -0,0 +1,508 @@
+From 13764867feabae242e5a21d4ceee38d3648d1b62 Mon Sep 17 00:00:00 2001
+From: "H.J. Lu" <hjl.tools@gmail.com>
+Date: Wed, 30 May 2012 14:13:18 -0700
+Subject: [PATCH] Use x86-64 bits/byteswap.h for both i386 and x86_64
+
+---
+ ChangeLog                         |  12 +++
+ sysdeps/i386/Implies              |   1 +
+ sysdeps/i386/bits/byteswap-16.h   |  49 ------------
+ sysdeps/i386/bits/byteswap.h      | 126 -------------------------------
+ sysdeps/x86/bits/byteswap-16.h    |  49 ++++++++++++
+ sysdeps/x86/bits/byteswap.h       | 154 ++++++++++++++++++++++++++++++++++++++
+ sysdeps/x86_64/Implies            |   1 +
+ sysdeps/x86_64/bits/byteswap-16.h |  49 ------------
+ sysdeps/x86_64/bits/byteswap.h    | 154 --------------------------------------
+ 9 files changed, 217 insertions(+), 378 deletions(-)
+ delete mode 100644 sysdeps/i386/bits/byteswap-16.h
+ delete mode 100644 sysdeps/i386/bits/byteswap.h
+ create mode 100644 sysdeps/x86/bits/byteswap-16.h
+ create mode 100644 sysdeps/x86/bits/byteswap.h
+ delete mode 100644 sysdeps/x86_64/bits/byteswap-16.h
+ delete mode 100644 sysdeps/x86_64/bits/byteswap.h
+
+diff -urN a/ChangeLog b/ChangeLog
+--- a/ChangeLog	2014-02-02 18:40:27.733311847 +0000
++++ b/ChangeLog	2014-02-02 18:43:05.462417779 +0000
+@@ -1,3 +1,15 @@
++2012-05-30  H.J. Lu  <hongjiu.lu@intel.com>
++
++        [BZ #14117]
++        * sysdeps/i386/bits/byteswap.h: Removed.
++        * sysdeps/i386/bits/byteswap-16.h: Likewise.
++        * sysdeps/x86_64/bits/byteswap.h: Renamed to ...
++        * sysdeps/x86/bits/byteswap.h: This.
++        * sysdeps/x86_64/bits/byteswap-16.h: Renamed to ...
++        * sysdeps/x86/bits/byteswap-16.h: This.
++        * sysdeps/i386/Implies: Add x86.
++        * sysdeps/x86_64/Implies: Likewise.
++
+ 2012-04-06  H.J. Lu  <hongjiu.lu@intel.com>
+ 
+        * bits/byteswap.h (__bswap_16): Removed.
+diff -urN a/sysdeps/i386/Implies b/sysdeps/i386/Implies
+--- a/sysdeps/i386/Implies	2014-02-02 18:40:27.863313907 +0000
++++ b/sysdeps/i386/Implies	2014-02-02 18:43:05.462417779 +0000
+@@ -1,3 +1,4 @@
++x86
+ wordsize-32
+ ieee754/ldbl-96
+ ieee754/dbl-64
+diff -urN a/sysdeps/i386/bits/byteswap.h b/sysdeps/i386/bits/byteswap.h
+--- a/sysdeps/i386/bits/byteswap.h	2014-02-02 18:40:27.866647269 +0000
++++ b/sysdeps/i386/bits/byteswap.h	1970-01-01 01:00:00.000000000 +0100
+@@ -1,112 +0,0 @@
+-/* Macros to swap the order of bytes in integer values.
+-   Copyright (C) 1997, 1998, 2000, 2002, 2003, 2006, 2007, 2008, 2010, 2011
+-   Free Software Foundation, Inc.
+-   This file is part of the GNU C Library.
+-
+-   The GNU C Library is free software; you can redistribute it and/or
+-   modify it under the terms of the GNU Lesser General Public
+-   License as published by the Free Software Foundation; either
+-   version 2.1 of the License, or (at your option) any later version.
+-
+-   The GNU C Library is distributed in the hope that it will be useful,
+-   but WITHOUT ANY WARRANTY; without even the implied warranty of
+-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+-   Lesser General Public License for more details.
+-
+-   You should have received a copy of the GNU Lesser General Public
+-   License along with the GNU C Library; if not, write to the Free
+-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+-   02111-1307 USA.  */
+-
+-#if !defined _BYTESWAP_H && !defined _NETINET_IN_H && !defined _ENDIAN_H
+-# error "Never use <bits/byteswap.h> directly; include <byteswap.h> instead."
+-#endif
+-
+-#ifndef _BITS_BYTESWAP_H
+-#define _BITS_BYTESWAP_H 1
+-
+-/* Swap bytes in 16 bit value.  */
+-#define __bswap_constant_16(x) \
+-     ((unsigned short int) ((((x) >> 8) & 0xff) | (((x) & 0xff) << 8)))
+-
+-/* Get __bswap_16.  */
+-#include <bits/byteswap-16.h>
+-
+-/* Swap bytes in 32 bit value.  */
+-#define __bswap_constant_32(x) \
+-     ((((x) & 0xff000000) >> 24) | (((x) & 0x00ff0000) >>  8) |		      \
+-      (((x) & 0x0000ff00) <<  8) | (((x) & 0x000000ff) << 24))
+-
+-#ifdef __GNUC__
+-# if __GNUC__ >= 2
+-/* To swap the bytes in a word the i486 processors and up provide the
+-   `bswap' opcode.  On i386 we have to use three instructions.  */
+-#  if !defined __i486__ && !defined __pentium__ && !defined __pentiumpro__ \
+-      && !defined __pentium4__ && !defined __k8__ && !defined __athlon__ \
+-      && !defined __k6__ && !defined __nocona__ && !defined __core2__ \
+-      && !defined __geode__ && !defined __amdfam10__
+-#   define __bswap_32(x)						      \
+-     (__extension__							      \
+-      ({ register unsigned int __v, __x = (x);				      \
+-	 if (__builtin_constant_p (__x))				      \
+-	   __v = __bswap_constant_32 (__x);				      \
+-	 else								      \
+-	   __asm__ ("rorw $8, %w0;"					      \
+-		    "rorl $16, %0;"					      \
+-		    "rorw $8, %w0"					      \
+-		    : "=r" (__v)					      \
+-		    : "0" (__x)						      \
+-		    : "cc");						      \
+-	 __v; }))
+-#  else
+-#   define __bswap_32(x) \
+-     (__extension__							      \
+-      ({ register unsigned int __v, __x = (x);				      \
+-	 if (__builtin_constant_p (__x))				      \
+-	   __v = __bswap_constant_32 (__x);				      \
+-	 else								      \
+-	   __asm__ ("bswap %0" : "=r" (__v) : "0" (__x));		      \
+-	 __v; }))
+-#  endif
+-# else
+-#  define __bswap_32(x) \
+-     (__extension__							      \
+-      ({ register unsigned int __x = (x); __bswap_constant_32 (__x); }))
+-# endif
+-#else
+-static __inline unsigned int
+-__bswap_32 (unsigned int __bsx)
+-{
+-  return __bswap_constant_32 (__bsx);
+-}
+-#endif
+-
+-
+-#if defined __GNUC__ && __GNUC__ >= 2
+-/* Swap bytes in 64 bit value.  */
+-# define __bswap_constant_64(x) \
+-     (__extension__ ((((x) & 0xff00000000000000ull) >> 56)		      \
+-		     | (((x) & 0x00ff000000000000ull) >> 40)		      \
+-		     | (((x) & 0x0000ff0000000000ull) >> 24)		      \
+-		     | (((x) & 0x000000ff00000000ull) >> 8)		      \
+-		     | (((x) & 0x00000000ff000000ull) << 8)		      \
+-		     | (((x) & 0x0000000000ff0000ull) << 24)		      \
+-		     | (((x) & 0x000000000000ff00ull) << 40)		      \
+-		     | (((x) & 0x00000000000000ffull) << 56)))
+-
+-# define __bswap_64(x) \
+-     (__extension__							      \
+-      ({ union { __extension__ unsigned long long int __ll;		      \
+-		 unsigned long int __l[2]; } __w, __r;			      \
+-	 if (__builtin_constant_p (x))					      \
+-	   __r.__ll = __bswap_constant_64 (x);				      \
+-	 else								      \
+-	   {								      \
+-	     __w.__ll = (x);						      \
+-	     __r.__l[0] = __bswap_32 (__w.__l[1]);			      \
+-	     __r.__l[1] = __bswap_32 (__w.__l[0]);			      \
+-	   }								      \
+-	 __r.__ll; }))
+-#endif
+-
+-#endif /* _BITS_BYTESWAP_H */
+diff -urN a/sysdeps/x86/bits/byteswap-16.h b/sysdeps/x86/bits/byteswap-16.h
+--- a/sysdeps/x86/bits/byteswap-16.h	1970-01-01 01:00:00.000000000 +0100
++++ b/sysdeps/x86/bits/byteswap-16.h	2014-02-02 18:43:12.859198918 +0000
+@@ -0,0 +1,49 @@
++/* Macros to swap the order of bytes in 16-bit integer values.
++   Copyright (C) 2012 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <http://www.gnu.org/licenses/>.  */
++
++#ifndef _BITS_BYTESWAP_H
++# error "Never use <bits/byteswap-16.h> directly; include <byteswap.h> instead."
++#endif
++
++#ifdef __GNUC__
++# if __GNUC__ >= 2
++#  define __bswap_16(x) \
++     (__extension__							      \
++      ({ register unsigned short int __v, __x = (unsigned short int) (x);     \
++	 if (__builtin_constant_p (__x))				      \
++	   __v = __bswap_constant_16 (__x);				      \
++	 else								      \
++	   __asm__ ("rorw $8, %w0"					      \
++		    : "=r" (__v)					      \
++		    : "0" (__x)						      \
++		    : "cc");						      \
++	 __v; }))
++# else
++/* This is better than nothing.  */
++#  define __bswap_16(x) \
++     (__extension__							      \
++      ({ register unsigned short int __x = (unsigned short int) (x);	      \
++	 __bswap_constant_16 (__x); }))
++# endif
++#else
++static __inline unsigned short int
++__bswap_16 (unsigned short int __bsx)
++{
++  return __bswap_constant_16 (__bsx);
++}
++#endif
+diff -urN a/sysdeps/x86/bits/byteswap.h b/sysdeps/x86/bits/byteswap.h
+--- a/sysdeps/x86/bits/byteswap.h	1970-01-01 01:00:00.000000000 +0100
++++ b/sysdeps/x86/bits/byteswap.h	2014-02-02 18:43:12.859198918 +0000
+@@ -0,0 +1,154 @@
++/* Macros to swap the order of bytes in integer values.
++   Copyright (C) 1997-2012   Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <http://www.gnu.org/licenses/>.  */
++
++#if !defined _BYTESWAP_H && !defined _NETINET_IN_H && !defined _ENDIAN_H
++# error "Never use <bits/byteswap.h> directly; include <byteswap.h> instead."
++#endif
++
++#ifndef _BITS_BYTESWAP_H
++#define _BITS_BYTESWAP_H 1
++
++#include <features.h>
++#include <bits/wordsize.h>
++
++/* Swap bytes in 16 bit value.  */
++#define __bswap_constant_16(x) \
++     ((unsigned short int) ((((x) >> 8) & 0xff) | (((x) & 0xff) << 8)))
++
++/* Get __bswap_16.  */
++#include <bits/byteswap-16.h>
++
++/* Swap bytes in 32 bit value.  */
++#define __bswap_constant_32(x) \
++     ((((x) & 0xff000000) >> 24) | (((x) & 0x00ff0000) >>  8) |		      \
++      (((x) & 0x0000ff00) <<  8) | (((x) & 0x000000ff) << 24))
++
++#ifdef __GNUC__
++# if __GNUC_PREREQ (4, 2)
++static __inline unsigned int
++__bswap_32 (unsigned int __bsx)
++{
++  return __builtin_bswap32 (__bsx);
++}
++# elif __GNUC__ >= 2
++#  if __WORDSIZE == 64 || (defined __i486__ || defined __pentium__	      \
++			   || defined __pentiumpro__ || defined __pentium4__  \
++			   || defined __k8__ || defined __athlon__	      \
++			   || defined __k6__ || defined __nocona__	      \
++			   || defined __core2__ || defined __geode__	      \
++			   || defined __amdfam10__)
++/* To swap the bytes in a word the i486 processors and up provide the
++   `bswap' opcode.  On i386 we have to use three instructions.  */
++#   define __bswap_32(x) \
++      (__extension__							      \
++       ({ register unsigned int __v, __x = (x);				      \
++	  if (__builtin_constant_p (__x))				      \
++	    __v = __bswap_constant_32 (__x);				      \
++	  else								      \
++	    __asm__ ("bswap %0" : "=r" (__v) : "0" (__x));		      \
++	  __v; }))
++#  else
++#   define __bswap_32(x)						      \
++      (__extension__							      \
++       ({ register unsigned int __v, __x = (x);				      \
++	  if (__builtin_constant_p (__x))				      \
++	    __v = __bswap_constant_32 (__x);				      \
++	  else								      \
++	    __asm__ ("rorw $8, %w0;"					      \
++		     "rorl $16, %0;"					      \
++		     "rorw $8, %w0"					      \
++		     : "=r" (__v)					      \
++		     : "0" (__x)					      \
++		     : "cc");						      \
++	  __v; }))
++#  endif
++# else
++#  define __bswap_32(x) \
++     (__extension__							      \
++      ({ register unsigned int __x = (x); __bswap_constant_32 (__x); }))
++# endif
++#else
++static __inline unsigned int
++__bswap_32 (unsigned int __bsx)
++{
++  return __bswap_constant_32 (__bsx);
++}
++#endif
++
++
++#if __GNUC_PREREQ (2, 0)
++/* Swap bytes in 64 bit value.  */
++# define __bswap_constant_64(x) \
++     (__extension__ ((((x) & 0xff00000000000000ull) >> 56)		      \
++		     | (((x) & 0x00ff000000000000ull) >> 40)		      \
++		     | (((x) & 0x0000ff0000000000ull) >> 24)		      \
++		     | (((x) & 0x000000ff00000000ull) >> 8)		      \
++		     | (((x) & 0x00000000ff000000ull) << 8)		      \
++		     | (((x) & 0x0000000000ff0000ull) << 24)		      \
++		     | (((x) & 0x000000000000ff00ull) << 40)		      \
++		     | (((x) & 0x00000000000000ffull) << 56)))
++
++# if __GNUC_PREREQ (4, 2)
++static __inline unsigned long long int
++__bswap_64 (unsigned long long int __bsx)
++{
++  return __builtin_bswap64 (__bsx);
++}
++# elif __WORDSIZE == 64
++#  define __bswap_64(x) \
++     (__extension__							      \
++      ({ register unsigned long __v, __x = (x);				      \
++	 if (__builtin_constant_p (__x))				      \
++	   __v = __bswap_constant_64 (__x);				      \
++	 else								      \
++	   __asm__ ("bswap %q0" : "=r" (__v) : "0" (__x));		      \
++	 __v; }))
++# else
++#  define __bswap_64(x) \
++     (__extension__                                                           \
++      ({ union { __extension__ unsigned long long int __ll;                   \
++		 unsigned int __l[2]; } __w, __r;                             \
++	 if (__builtin_constant_p (x))                                        \
++	   __r.__ll = __bswap_constant_64 (x);                                \
++	 else                                                                 \
++	   {                                                                  \
++	     __w.__ll = (x);                                                  \
++	     __r.__l[0] = __bswap_32 (__w.__l[1]);                            \
++	     __r.__l[1] = __bswap_32 (__w.__l[0]);                            \
++	   }                                                                  \
++	 __r.__ll; }))
++# endif
++#elif __GLIBC_HAVE_LONG_LONG
++# define __bswap_constant_64(x) \
++     ((((x) & 0xff00000000000000ull) >> 56)				      \
++      | (((x) & 0x00ff000000000000ull) >> 40)				      \
++      | (((x) & 0x0000ff0000000000ull) >> 24)				      \
++      | (((x) & 0x000000ff00000000ull) >> 8)				      \
++      | (((x) & 0x00000000ff000000ull) << 8)				      \
++      | (((x) & 0x0000000000ff0000ull) << 24)				      \
++      | (((x) & 0x000000000000ff00ull) << 40)				      \
++      | (((x) & 0x00000000000000ffull) << 56))
++
++static __inline unsigned long long int
++__bswap_64 (unsigned long long int __bsx)
++{
++  return __bswap_constant_64 (__bsx);
++}
++#endif
++
++#endif /* _BITS_BYTESWAP_H */
+diff -urN a/sysdeps/x86_64/Implies b/sysdeps/x86_64/Implies
+--- a/sysdeps/x86_64/Implies	2014-02-02 18:40:27.866647269 +0000
++++ b/sysdeps/x86_64/Implies	2014-02-02 18:43:12.859198918 +0000
+@@ -1,3 +1,4 @@
++x86
+ wordsize-64
+ ieee754/ldbl-96
+ ieee754/dbl-64/wordsize-64
+diff -urN a/sysdeps/x86_64/bits/byteswap.h b/sysdeps/x86_64/bits/byteswap.h
+--- a/sysdeps/x86_64/bits/byteswap.h	2014-02-02 18:40:27.869980643 +0000
++++ b/sysdeps/x86_64/bits/byteswap.h	1970-01-01 01:00:00.000000000 +0100
+@@ -1,119 +0,0 @@
+-/* Macros to swap the order of bytes in integer values.
+-   Copyright (C) 1997, 1998, 2000, 2002, 2003, 2007, 2008, 2010, 2011
+-   Free Software Foundation, Inc.
+-   This file is part of the GNU C Library.
+-
+-   The GNU C Library is free software; you can redistribute it and/or
+-   modify it under the terms of the GNU Lesser General Public
+-   License as published by the Free Software Foundation; either
+-   version 2.1 of the License, or (at your option) any later version.
+-
+-   The GNU C Library is distributed in the hope that it will be useful,
+-   but WITHOUT ANY WARRANTY; without even the implied warranty of
+-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+-   Lesser General Public License for more details.
+-
+-   You should have received a copy of the GNU Lesser General Public
+-   License along with the GNU C Library; if not, write to the Free
+-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+-   02111-1307 USA.  */
+-
+-#if !defined _BYTESWAP_H && !defined _NETINET_IN_H && !defined _ENDIAN_H
+-# error "Never use <bits/byteswap.h> directly; include <byteswap.h> instead."
+-#endif
+-
+-#ifndef _BITS_BYTESWAP_H
+-#define _BITS_BYTESWAP_H 1
+-
+-#include <bits/wordsize.h>
+-
+-/* Swap bytes in 16 bit value.  */
+-#define __bswap_constant_16(x) \
+-     ((unsigned short int) ((((x) >> 8) & 0xff) | (((x) & 0xff) << 8)))
+-
+-/* Get __bswap_16.  */
+-#include <bits/byteswap-16.h>
+-
+-/* Swap bytes in 32 bit value.  */
+-#define __bswap_constant_32(x) \
+-     ((((x) & 0xff000000) >> 24) | (((x) & 0x00ff0000) >>  8) |		      \
+-      (((x) & 0x0000ff00) <<  8) | (((x) & 0x000000ff) << 24))
+-
+-#if defined __GNUC__ && __GNUC__ >= 2
+-# if __WORDSIZE == 64 || (defined __i486__ || defined __pentium__	      \
+-			  || defined __pentiumpro__ || defined __pentium4__   \
+-			  || defined __k8__ || defined __athlon__	      \
+-			  || defined __k6__ || defined __nocona__	      \
+-			  || defined __core2__ || defined __geode__	      \
+-			  || defined __amdfam10__)
+-/* To swap the bytes in a word the i486 processors and up provide the
+-   `bswap' opcode.  On i386 we have to use three instructions.  */
+-#  define __bswap_32(x) \
+-     (__extension__							      \
+-      ({ register unsigned int __v, __x = (x);				      \
+-	 if (__builtin_constant_p (__x))				      \
+-	   __v = __bswap_constant_32 (__x);				      \
+-	 else								      \
+-	   __asm__ ("bswap %0" : "=r" (__v) : "0" (__x));		      \
+-	 __v; }))
+-# else
+-#  define __bswap_32(x)							      \
+-     (__extension__							      \
+-      ({ register unsigned int __v, __x = (x);				      \
+-	 if (__builtin_constant_p (__x))				      \
+-	   __v = __bswap_constant_32 (__x);				      \
+-	 else								      \
+-	   __asm__ ("rorw $8, %w0;"					      \
+-		    "rorl $16, %0;"					      \
+-		    "rorw $8, %w0"					      \
+-		    : "=r" (__v)					      \
+-		    : "0" (__x)						      \
+-		    : "cc");						      \
+-	 __v; }))
+-# endif
+-#else
+-# define __bswap_32(x) \
+-     (__extension__							      \
+-      ({ register unsigned int __x = (x); __bswap_constant_32 (__x); }))
+-#endif
+-
+-
+-#if defined __GNUC__ && __GNUC__ >= 2
+-/* Swap bytes in 64 bit value.  */
+-# define __bswap_constant_64(x) \
+-     (__extension__ ((((x) & 0xff00000000000000ull) >> 56)		      \
+-		     | (((x) & 0x00ff000000000000ull) >> 40)		      \
+-		     | (((x) & 0x0000ff0000000000ull) >> 24)		      \
+-		     | (((x) & 0x000000ff00000000ull) >> 8)		      \
+-		     | (((x) & 0x00000000ff000000ull) << 8)		      \
+-		     | (((x) & 0x0000000000ff0000ull) << 24)		      \
+-		     | (((x) & 0x000000000000ff00ull) << 40)		      \
+-		     | (((x) & 0x00000000000000ffull) << 56)))
+-
+-# if __WORDSIZE == 64
+-#  define __bswap_64(x) \
+-     (__extension__							      \
+-      ({ register unsigned long __v, __x = (x);				      \
+-	 if (__builtin_constant_p (__x))				      \
+-	   __v = __bswap_constant_64 (__x);				      \
+-	 else								      \
+-	   __asm__ ("bswap %q0" : "=r" (__v) : "0" (__x));		      \
+-	 __v; }))
+-# else
+-#  define __bswap_64(x) \
+-     (__extension__                                                           \
+-      ({ union { __extension__ unsigned long long int __ll;                   \
+-		 unsigned int __l[2]; } __w, __r;                             \
+-	 if (__builtin_constant_p (x))                                        \
+-	   __r.__ll = __bswap_constant_64 (x);                                \
+-	 else                                                                 \
+-	   {                                                                  \
+-	     __w.__ll = (x);                                                  \
+-	     __r.__l[0] = __bswap_32 (__w.__l[1]);                            \
+-	     __r.__l[1] = __bswap_32 (__w.__l[0]);                            \
+-	   }                                                                  \
+-	 __r.__ll; }))
+-# endif
+-#endif
+-
+-#endif /* _BITS_BYTESWAP_H */
diff --git a/patches/glibc/2.15/002-BZ14117-Use-x86_64-bits-mathdef.h-for-i386-x86_64.patch b/patches/glibc/2.15/002-BZ14117-Use-x86_64-bits-mathdef.h-for-i386-x86_64.patch
new file mode 100644
index 0000000..7c360f3
--- /dev/null
+++ b/patches/glibc/2.15/002-BZ14117-Use-x86_64-bits-mathdef.h-for-i386-x86_64.patch
@@ -0,0 +1,225 @@
+From 7dc00e0d3c1f94b00ee49052c65da50f0795c8a2 Mon Sep 17 00:00:00 2001
+From: "H.J. Lu" <hjl.tools@gmail.com>
+Date: Wed, 30 May 2012 15:42:28 -0700
+Subject: [PATCH] Use x86_64 bits/mathdef.h for i386/x86_64
+
+---
+ ChangeLog                     |  7 +++++
+ sysdeps/i386/bits/mathdef.h   | 59 -------------------------------------------
+ sysdeps/x86/bits/mathdef.h    | 59 +++++++++++++++++++++++++++++++++++++++++++
+ sysdeps/x86_64/bits/mathdef.h | 59 -------------------------------------------
+ 4 files changed, 66 insertions(+), 118 deletions(-)
+ delete mode 100644 sysdeps/i386/bits/mathdef.h
+ create mode 100644 sysdeps/x86/bits/mathdef.h
+ delete mode 100644 sysdeps/x86_64/bits/mathdef.h
+
+diff -urN a/ChangeLog b/ChangeLog
+--- a/ChangeLog	2014-01-31 00:24:07.066787423 +0000
++++ b/ChangeLog	2014-01-31 00:27:02.169495336 +0000
+@@ -1,6 +1,13 @@
+ 2012-05-30  H.J. Lu  <hongjiu.lu@intel.com>
+ 
+         [BZ #14117]
++        * sysdeps/i386/bits/mathdef.h: Removed.
++        * sysdeps/x86_64/bits/mathdef.h: Renamed to ...
++        * sysdeps/x86/bits/mathdef.h: This.
++
++2012-05-30  H.J. Lu  <hongjiu.lu@intel.com>
++
++        [BZ #14117]
+         * sysdeps/i386/bits/byteswap.h: Removed.
+         * sysdeps/i386/bits/byteswap-16.h: Likewise.
+         * sysdeps/x86_64/bits/byteswap.h: Renamed to ...
+diff -urN a/sysdeps/i386/bits/mathdef.h b/sysdeps/i386/bits/mathdef.h
+--- a/sysdeps/i386/bits/mathdef.h	2012-01-01 12:16:32.000000000 +0000
++++ b/sysdeps/i386/bits/mathdef.h	1970-01-01 01:00:00.000000000 +0100
+@@ -1,60 +0,0 @@
+-/* Copyright (C) 1997, 1998, 1999, 2000, 2004, 2010 Free Software Foundation, Inc.
+-   This file is part of the GNU C Library.
+-
+-   The GNU C Library is free software; you can redistribute it and/or
+-   modify it under the terms of the GNU Lesser General Public
+-   License as published by the Free Software Foundation; either
+-   version 2.1 of the License, or (at your option) any later version.
+-
+-   The GNU C Library is distributed in the hope that it will be useful,
+-   but WITHOUT ANY WARRANTY; without even the implied warranty of
+-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+-   Lesser General Public License for more details.
+-
+-   You should have received a copy of the GNU Lesser General Public
+-   License along with the GNU C Library; if not, write to the Free
+-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+-   02111-1307 USA.  */
+-
+-#if !defined _MATH_H && !defined _COMPLEX_H
+-# error "Never use <bits/mathdef.h> directly; include <math.h> instead"
+-#endif
+-
+-#if defined __USE_ISOC99 && defined _MATH_H && !defined _MATH_H_MATHDEF
+-# define _MATH_H_MATHDEF	1
+-
+-# if defined __FLT_EVAL_METHOD__ && __FLT_EVAL_METHOD__ == 0
+-/* When using -mfpmath=sse, values are computed with the precission of the
+-   used type.  */
+-typedef float float_t;		/* `float' expressions are evaluated as `float'.  */
+-typedef double double_t;	/* `double' expressions are evaluated as
+-				   `double'.  */
+-# else
+-/* The ix87 FPUs evaluate all values in the 80 bit floating-point format
+-   which is also available for the user as `long double'.  Therefore we
+-   define:  */
+-typedef long double float_t;	/* `float' expressions are evaluated as
+-				   `long double'.  */
+-typedef long double double_t;	/* `double' expressions are evaluated as
+-				   `long double'.  */
+-# endif
+-
+-/* The values returned by `ilogb' for 0 and NaN respectively.  */
+-# define FP_ILOGB0	(-2147483647 - 1)
+-# define FP_ILOGBNAN	(-2147483647 - 1)
+-
+-/* The GCC 4.6 compiler will define __FP_FAST_FMA{,F,L} if the fma{,f,l}
+-   builtins are supported.  */
+-# if __FP_FAST_FMA
+-#  define FP_FAST_FMA 1
+-# endif
+-
+-# if __FP_FAST_FMAF
+-#  define FP_FAST_FMAF 1
+-# endif
+-
+-# if __FP_FAST_FMAL
+-#  define FP_FAST_FMAL 1
+-# endif
+-
+-#endif	/* ISO C99 */
+diff -urN a/sysdeps/x86/bits/mathdef.h b/sysdeps/x86/bits/mathdef.h
+--- a/sysdeps/x86/bits/mathdef.h	1970-01-01 01:00:00.000000000 +0100
++++ b/sysdeps/x86/bits/mathdef.h	2014-01-31 00:24:43.917357358 +0000
+@@ -0,0 +1,59 @@
++/* Copyright (C) 2001-2012 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <http://www.gnu.org/licenses/>.  */
++
++#if !defined _MATH_H && !defined _COMPLEX_H
++# error "Never use <bits/mathdef.h> directly; include <math.h> instead"
++#endif
++
++#if defined __USE_ISOC99 && defined _MATH_H && !defined _MATH_H_MATHDEF
++# define _MATH_H_MATHDEF	1
++
++# if defined __x86_64__ || (defined __FLT_EVAL_METHOD__ && __FLT_EVAL_METHOD__ == 0)
++/* The x86-64 architecture computes values with the precission of the
++   used type.  Similarly for -m32 -mfpmath=sse.  */
++typedef float float_t;		/* `float' expressions are evaluated as `float'.  */
++typedef double double_t;	/* `double' expressions are evaluated
++				   as `double'.  */
++# else
++/* The ix87 FPUs evaluate all values in the 80 bit floating-point format
++   which is also available for the user as `long double'.  Therefore we
++   define:  */
++typedef long double float_t;	/* `float' expressions are evaluated as
++				   `long double'.  */
++typedef long double double_t;	/* `double' expressions are evaluated as
++				   `long double'.  */
++# endif
++
++/* The values returned by `ilogb' for 0 and NaN respectively.  */
++# define FP_ILOGB0	(-2147483647 - 1)
++# define FP_ILOGBNAN	(-2147483647 - 1)
++
++/* The GCC 4.6 compiler will define __FP_FAST_FMA{,F,L} if the fma{,f,l}
++   builtins are supported.  */
++# if __FP_FAST_FMA
++#  define FP_FAST_FMA 1
++# endif
++
++# if __FP_FAST_FMAF
++#  define FP_FAST_FMAF 1
++# endif
++
++# if __FP_FAST_FMAL
++#  define FP_FAST_FMAL 1
++# endif
++
++#endif	/* ISO C99 */
+diff -urN a/sysdeps/x86_64/bits/mathdef.h b/sysdeps/x86_64/bits/mathdef.h
+--- a/sysdeps/x86_64/bits/mathdef.h	2012-01-01 12:16:32.000000000 +0000
++++ b/sysdeps/x86_64/bits/mathdef.h	1970-01-01 01:00:00.000000000 +0100
+@@ -1,62 +0,0 @@
+-/* Copyright (C) 2001, 2004, 2010 Free Software Foundation, Inc.
+-   This file is part of the GNU C Library.
+-
+-   The GNU C Library is free software; you can redistribute it and/or
+-   modify it under the terms of the GNU Lesser General Public
+-   License as published by the Free Software Foundation; either
+-   version 2.1 of the License, or (at your option) any later version.
+-
+-   The GNU C Library is distributed in the hope that it will be useful,
+-   but WITHOUT ANY WARRANTY; without even the implied warranty of
+-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+-   Lesser General Public License for more details.
+-
+-   You should have received a copy of the GNU Lesser General Public
+-   License along with the GNU C Library; if not, write to the Free
+-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+-   02111-1307 USA.  */
+-
+-#if !defined _MATH_H && !defined _COMPLEX_H
+-# error "Never use <bits/mathdef.h> directly; include <math.h> instead"
+-#endif
+-
+-#if defined __USE_ISOC99 && defined _MATH_H && !defined _MATH_H_MATHDEF
+-# define _MATH_H_MATHDEF	1
+-
+-# include <bits/wordsize.h>
+-
+-# if __WORDSIZE == 64 || (defined __FLT_EVAL_METHOD__ && __FLT_EVAL_METHOD__ == 0)
+-/* The x86-64 architecture computes values with the precission of the
+-   used type.  Similarly for -m32 -mfpmath=sse.  */
+-typedef float float_t;		/* `float' expressions are evaluated as `float'.  */
+-typedef double double_t;	/* `double' expressions are evaluated
+-				   as `double'.  */
+-# else
+-/* The ix87 FPUs evaluate all values in the 80 bit floating-point format
+-   which is also available for the user as `long double'.  Therefore we
+-   define:  */
+-typedef long double float_t;	/* `float' expressions are evaluated as
+-				   `long double'.  */
+-typedef long double double_t;	/* `double' expressions are evaluated as
+-				   `long double'.  */
+-# endif
+-
+-/* The values returned by `ilogb' for 0 and NaN respectively.  */
+-# define FP_ILOGB0	(-2147483647 - 1)
+-# define FP_ILOGBNAN	(-2147483647 - 1)
+-
+-/* The GCC 4.6 compiler will define __FP_FAST_FMA{,F,L} if the fma{,f,l}
+-   builtins are supported.  */
+-# if __FP_FAST_FMA
+-#  define FP_FAST_FMA 1
+-# endif
+-
+-# if __FP_FAST_FMAF
+-#  define FP_FAST_FMAF 1
+-# endif
+-
+-# if __FP_FAST_FMAL
+-#  define FP_FAST_FMAL 1
+-# endif
+-
+-#endif	/* ISO C99 */
diff --git a/patches/glibc/2.15/003-BZ14117-Use-x86-64-bits-pthreadtypes.h-semaphore.h-for-i386-.patch b/patches/glibc/2.15/003-BZ14117-Use-x86-64-bits-pthreadtypes.h-semaphore.h-for-i386-.patch
new file mode 100644
index 0000000..e358b42
--- /dev/null
+++ b/patches/glibc/2.15/003-BZ14117-Use-x86-64-bits-pthreadtypes.h-semaphore.h-for-i386-.patch
@@ -0,0 +1,835 @@
+From 0e20515a17445ec961a05b14a7355b79fc421564 Mon Sep 17 00:00:00 2001
+From: "H.J. Lu" <hjl.tools@gmail.com>
+Date: Wed, 30 May 2012 17:29:22 -0700
+Subject: [PATCH] Use x86-64 bits/pthreadtypes.h/semaphore.h for i386/x86-64
+
+---
+ nptl/ChangeLog                                     |  14 ++
+ nptl/sysdeps/unix/sysv/linux/i386/Implies          |   1 +
+ .../unix/sysv/linux/i386/bits/pthreadtypes.h       | 176 ---------------
+ nptl/sysdeps/unix/sysv/linux/i386/bits/semaphore.h |  35 ---
+ .../unix/sysv/linux/x86/bits/pthreadtypes.h        | 240 +++++++++++++++++++++
+ nptl/sysdeps/unix/sysv/linux/x86/bits/semaphore.h  |  40 ++++
+ nptl/sysdeps/unix/sysv/linux/x86_64/Implies        |   1 +
+ .../unix/sysv/linux/x86_64/bits/pthreadtypes.h     | 240 ---------------------
+ .../unix/sysv/linux/x86_64/bits/semaphore.h        |  40 ----
+ 9 files changed, 296 insertions(+), 491 deletions(-)
+ create mode 100644 nptl/sysdeps/unix/sysv/linux/i386/Implies
+ delete mode 100644 nptl/sysdeps/unix/sysv/linux/i386/bits/pthreadtypes.h
+ delete mode 100644 nptl/sysdeps/unix/sysv/linux/i386/bits/semaphore.h
+ create mode 100644 nptl/sysdeps/unix/sysv/linux/x86/bits/pthreadtypes.h
+ create mode 100644 nptl/sysdeps/unix/sysv/linux/x86/bits/semaphore.h
+ create mode 100644 nptl/sysdeps/unix/sysv/linux/x86_64/Implies
+ delete mode 100644 nptl/sysdeps/unix/sysv/linux/x86_64/bits/pthreadtypes.h
+ delete mode 100644 nptl/sysdeps/unix/sysv/linux/x86_64/bits/semaphore.h
+
+diff -urN a/nptl/ChangeLog b/nptl/ChangeLog
+--- a/nptl/ChangeLog	2014-01-31 00:30:29.406033517 +0000
++++ b/nptl/ChangeLog	2014-01-31 00:34:56.463496814 +0000
+@@ -1,3 +1,17 @@
++2012-05-30  H.J. Lu  <hongjiu.lu@intel.com>
++
++        [BZ #14117]
++        * sysdeps/unix/sysv/linux/i386/bits/pthreadtypes.h: Removed.
++        * sysdeps/unix/sysv/linux/i386/bits/semaphore.h: Likewise.
++        * sysdeps/unix/sysv/linux/i386/Implies: New file.
++        * sysdeps/unix/sysv/linux/x86_64/Implies: Likewise.
++        * sysdeps/unix/sysv/linux/x86_64/bits/pthreadtypes.h: Renamed
++        to ...
++        * sysdeps/unix/sysv/linux/x86/bits/pthreadtypes.h: This.
++        * sysdeps/unix/sysv/linux/x86_64/bits/semaphore.h: Renamed
++        to ...
++        * sysdeps/unix/sysv/linux/x86/bits/semaphore.h: This.
++
+ 2011-12-22  Ulrich Drepper  <drepper@gmail.com>
+ 
+ 	* sysdeps/pthread/gai_misc.h (__gai_create_helper_thread): Use
+diff -urN a/nptl/sysdeps/unix/sysv/linux/i386/Implies b/nptl/sysdeps/unix/sysv/linux/i386/Implies
+--- a/nptl/sysdeps/unix/sysv/linux/i386/Implies	1970-01-01 01:00:00.000000000 +0100
++++ b/nptl/sysdeps/unix/sysv/linux/i386/Implies	2014-01-31 00:30:47.776317692 +0000
+@@ -0,0 +1 @@
++unix/sysv/linux/x86
+diff -urN a/nptl/sysdeps/unix/sysv/linux/i386/bits/pthreadtypes.h b/nptl/sysdeps/unix/sysv/linux/i386/bits/pthreadtypes.h
+--- a/nptl/sysdeps/unix/sysv/linux/i386/bits/pthreadtypes.h	2014-01-31 00:30:29.399366766 +0000
++++ b/nptl/sysdeps/unix/sysv/linux/i386/bits/pthreadtypes.h	1970-01-01 01:00:00.000000000 +0100
+@@ -1,173 +0,0 @@
+-/* Copyright (C) 2002,2003,2004,2005,2006,2007 Free Software Foundation, Inc.
+-   This file is part of the GNU C Library.
+-
+-   The GNU C Library is free software; you can redistribute it and/or
+-   modify it under the terms of the GNU Lesser General Public
+-   License as published by the Free Software Foundation; either
+-   version 2.1 of the License, or (at your option) any later version.
+-
+-   The GNU C Library is distributed in the hope that it will be useful,
+-   but WITHOUT ANY WARRANTY; without even the implied warranty of
+-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+-   Lesser General Public License for more details.
+-
+-   You should have received a copy of the GNU Lesser General Public
+-   License along with the GNU C Library; if not, write to the Free
+-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+-   02111-1307 USA.  */
+-
+-#ifndef _BITS_PTHREADTYPES_H
+-#define _BITS_PTHREADTYPES_H	1
+-
+-#define __SIZEOF_PTHREAD_ATTR_T 36
+-#define __SIZEOF_PTHREAD_MUTEX_T 24
+-#define __SIZEOF_PTHREAD_MUTEXATTR_T 4
+-#define __SIZEOF_PTHREAD_COND_T 48
+-#define __SIZEOF_PTHREAD_COND_COMPAT_T 12
+-#define __SIZEOF_PTHREAD_CONDATTR_T 4
+-#define __SIZEOF_PTHREAD_RWLOCK_T 32
+-#define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
+-#define __SIZEOF_PTHREAD_BARRIER_T 20
+-#define __SIZEOF_PTHREAD_BARRIERATTR_T 4
+-
+-
+-/* Thread identifiers.  The structure of the attribute type is not
+-   exposed on purpose.  */
+-typedef unsigned long int pthread_t;
+-
+-
+-typedef union
+-{
+-  char __size[__SIZEOF_PTHREAD_ATTR_T];
+-  long int __align;
+-} pthread_attr_t;
+-
+-
+-typedef struct __pthread_internal_slist
+-{
+-  struct __pthread_internal_slist *__next;
+-} __pthread_slist_t;
+-
+-
+-/* Data structures for mutex handling.  The structure of the attribute
+-   type is not exposed on purpose.  */
+-typedef union
+-{
+-  struct __pthread_mutex_s
+-  {
+-    int __lock;
+-    unsigned int __count;
+-    int __owner;
+-    /* KIND must stay at this position in the structure to maintain
+-       binary compatibility.  */
+-    int __kind;
+-    unsigned int __nusers;
+-    __extension__ union
+-    {
+-      int __spins;
+-      __pthread_slist_t __list;
+-    };
+-  } __data;
+-  char __size[__SIZEOF_PTHREAD_MUTEX_T];
+-  long int __align;
+-} pthread_mutex_t;
+-
+-typedef union
+-{
+-  char __size[__SIZEOF_PTHREAD_MUTEXATTR_T];
+-  long int __align;
+-} pthread_mutexattr_t;
+-
+-
+-/* Data structure for conditional variable handling.  The structure of
+-   the attribute type is not exposed on purpose.  */
+-typedef union
+-{
+-  struct
+-  {
+-    int __lock;
+-    unsigned int __futex;
+-    __extension__ unsigned long long int __total_seq;
+-    __extension__ unsigned long long int __wakeup_seq;
+-    __extension__ unsigned long long int __woken_seq;
+-    void *__mutex;
+-    unsigned int __nwaiters;
+-    unsigned int __broadcast_seq;
+-  } __data;
+-  char __size[__SIZEOF_PTHREAD_COND_T];
+-  __extension__ long long int __align;
+-} pthread_cond_t;
+-
+-typedef union
+-{
+-  char __size[__SIZEOF_PTHREAD_CONDATTR_T];
+-  long int __align;
+-} pthread_condattr_t;
+-
+-
+-/* Keys for thread-specific data */
+-typedef unsigned int pthread_key_t;
+-
+-
+-/* Once-only execution */
+-typedef int pthread_once_t;
+-
+-
+-#if defined __USE_UNIX98 || defined __USE_XOPEN2K
+-/* Data structure for read-write lock variable handling.  The
+-   structure of the attribute type is not exposed on purpose.  */
+-typedef union
+-{
+-  struct
+-  {
+-    int __lock;
+-    unsigned int __nr_readers;
+-    unsigned int __readers_wakeup;
+-    unsigned int __writer_wakeup;
+-    unsigned int __nr_readers_queued;
+-    unsigned int __nr_writers_queued;
+-    /* FLAGS must stay at this position in the structure to maintain
+-       binary compatibility.  */
+-    unsigned char __flags;
+-    unsigned char __shared;
+-    unsigned char __pad1;
+-    unsigned char __pad2;
+-    int __writer;
+-  } __data;
+-  char __size[__SIZEOF_PTHREAD_RWLOCK_T];
+-  long int __align;
+-} pthread_rwlock_t;
+-
+-typedef union
+-{
+-  char __size[__SIZEOF_PTHREAD_RWLOCKATTR_T];
+-  long int __align;
+-} pthread_rwlockattr_t;
+-#endif
+-
+-
+-#ifdef __USE_XOPEN2K
+-/* POSIX spinlock data type.  */
+-typedef volatile int pthread_spinlock_t;
+-
+-
+-/* POSIX barriers data type.  The structure of the type is
+-   deliberately not exposed.  */
+-typedef union
+-{
+-  char __size[__SIZEOF_PTHREAD_BARRIER_T];
+-  long int __align;
+-} pthread_barrier_t;
+-
+-typedef union
+-{
+-  char __size[__SIZEOF_PTHREAD_BARRIERATTR_T];
+-  int __align;
+-} pthread_barrierattr_t;
+-#endif
+-
+-
+-/* Extra attributes for the cleanup functions.  */
+-#define __cleanup_fct_attribute __attribute__ ((__regparm__ (1)))
+-
+-#endif	/* bits/pthreadtypes.h */
+diff -urN a/nptl/sysdeps/unix/sysv/linux/i386/bits/semaphore.h b/nptl/sysdeps/unix/sysv/linux/i386/bits/semaphore.h
+--- a/nptl/sysdeps/unix/sysv/linux/i386/bits/semaphore.h	2014-01-31 00:30:29.399366766 +0000
++++ b/nptl/sysdeps/unix/sysv/linux/i386/bits/semaphore.h	1970-01-01 01:00:00.000000000 +0100
+@@ -1,36 +0,0 @@
+-/* Copyright (C) 2002 Free Software Foundation, Inc.
+-   This file is part of the GNU C Library.
+-   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
+-
+-   The GNU C Library is free software; you can redistribute it and/or
+-   modify it under the terms of the GNU Lesser General Public
+-   License as published by the Free Software Foundation; either
+-   version 2.1 of the License, or (at your option) any later version.
+-
+-   The GNU C Library is distributed in the hope that it will be useful,
+-   but WITHOUT ANY WARRANTY; without even the implied warranty of
+-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+-   Lesser General Public License for more details.
+-
+-   You should have received a copy of the GNU Lesser General Public
+-   License along with the GNU C Library; if not, write to the Free
+-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+-   02111-1307 USA.  */
+-
+-#ifndef _SEMAPHORE_H
+-# error "Never use <bits/semaphore.h> directly; include <semaphore.h> instead."
+-#endif
+-
+-
+-#define __SIZEOF_SEM_T	16
+-
+-
+-/* Value returned if `sem_open' failed.  */
+-#define SEM_FAILED      ((sem_t *) 0)
+-
+-
+-typedef union
+-{
+-  char __size[__SIZEOF_SEM_T];
+-  long int __align;
+-} sem_t;
+diff -urN a/nptl/sysdeps/unix/sysv/linux/x86/bits/pthreadtypes.h b/nptl/sysdeps/unix/sysv/linux/x86/bits/pthreadtypes.h
+--- a/nptl/sysdeps/unix/sysv/linux/x86/bits/pthreadtypes.h	1970-01-01 01:00:00.000000000 +0100
++++ b/nptl/sysdeps/unix/sysv/linux/x86/bits/pthreadtypes.h	2014-01-31 00:31:00.639849812 +0000
+@@ -0,0 +1,240 @@
++/* Copyright (C) 2002-2007, 2012 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <http://www.gnu.org/licenses/>.  */
++
++#ifndef _BITS_PTHREADTYPES_H
++#define _BITS_PTHREADTYPES_H	1
++
++#include <bits/wordsize.h>
++
++#ifdef __x86_64__
++# if __WORDSIZE == 64
++#  define __SIZEOF_PTHREAD_ATTR_T 56
++#  define __SIZEOF_PTHREAD_MUTEX_T 40
++#  define __SIZEOF_PTHREAD_MUTEXATTR_T 4
++#  define __SIZEOF_PTHREAD_COND_T 48
++#  define __SIZEOF_PTHREAD_CONDATTR_T 4
++#  define __SIZEOF_PTHREAD_RWLOCK_T 56
++#  define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
++#  define __SIZEOF_PTHREAD_BARRIER_T 32
++#  define __SIZEOF_PTHREAD_BARRIERATTR_T 4
++# else
++#  define __SIZEOF_PTHREAD_ATTR_T 32
++#  define __SIZEOF_PTHREAD_MUTEX_T 32
++#  define __SIZEOF_PTHREAD_MUTEXATTR_T 4
++#  define __SIZEOF_PTHREAD_COND_T 48
++#  define __SIZEOF_PTHREAD_CONDATTR_T 4
++#  define __SIZEOF_PTHREAD_RWLOCK_T 44
++#  define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
++#  define __SIZEOF_PTHREAD_BARRIER_T 20
++#  define __SIZEOF_PTHREAD_BARRIERATTR_T 4
++# endif
++#else
++# define __SIZEOF_PTHREAD_ATTR_T 36
++# define __SIZEOF_PTHREAD_MUTEX_T 24
++# define __SIZEOF_PTHREAD_MUTEXATTR_T 4
++# define __SIZEOF_PTHREAD_COND_T 48
++# define __SIZEOF_PTHREAD_CONDATTR_T 4
++# define __SIZEOF_PTHREAD_RWLOCK_T 32
++# define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
++# define __SIZEOF_PTHREAD_BARRIER_T 20
++# define __SIZEOF_PTHREAD_BARRIERATTR_T 4
++#endif
++
++
++/* Thread identifiers.  The structure of the attribute type is not
++   exposed on purpose.  */
++typedef unsigned long int pthread_t;
++
++
++union pthread_attr_t
++{
++  char __size[__SIZEOF_PTHREAD_ATTR_T];
++  long int __align;
++};
++#ifndef __have_pthread_attr_t
++typedef union pthread_attr_t pthread_attr_t;
++# define __have_pthread_attr_t	1
++#endif
++
++
++#ifdef __x86_64__
++typedef struct __pthread_internal_list
++{
++  struct __pthread_internal_list *__prev;
++  struct __pthread_internal_list *__next;
++} __pthread_list_t;
++#else
++typedef struct __pthread_internal_slist
++{
++  struct __pthread_internal_slist *__next;
++} __pthread_slist_t;
++#endif
++
++
++/* Data structures for mutex handling.  The structure of the attribute
++   type is not exposed on purpose.  */
++typedef union
++{
++  struct __pthread_mutex_s
++  {
++    int __lock;
++    unsigned int __count;
++    int __owner;
++#ifdef __x86_64__
++    unsigned int __nusers;
++#endif
++    /* KIND must stay at this position in the structure to maintain
++       binary compatibility.  */
++    int __kind;
++#ifdef __x86_64__
++    int __spins;
++    __pthread_list_t __list;
++# define __PTHREAD_MUTEX_HAVE_PREV	1
++#else
++    unsigned int __nusers;
++    __extension__ union
++    {
++      int __spins;
++      __pthread_slist_t __list;
++    };
++#endif
++  } __data;
++  char __size[__SIZEOF_PTHREAD_MUTEX_T];
++  long int __align;
++} pthread_mutex_t;
++
++typedef union
++{
++  char __size[__SIZEOF_PTHREAD_MUTEXATTR_T];
++  int __align;
++} pthread_mutexattr_t;
++
++
++/* Data structure for conditional variable handling.  The structure of
++   the attribute type is not exposed on purpose.  */
++typedef union
++{
++  struct
++  {
++    int __lock;
++    unsigned int __futex;
++    __extension__ unsigned long long int __total_seq;
++    __extension__ unsigned long long int __wakeup_seq;
++    __extension__ unsigned long long int __woken_seq;
++    void *__mutex;
++    unsigned int __nwaiters;
++    unsigned int __broadcast_seq;
++  } __data;
++  char __size[__SIZEOF_PTHREAD_COND_T];
++  __extension__ long long int __align;
++} pthread_cond_t;
++
++typedef union
++{
++  char __size[__SIZEOF_PTHREAD_CONDATTR_T];
++  int __align;
++} pthread_condattr_t;
++
++
++/* Keys for thread-specific data */
++typedef unsigned int pthread_key_t;
++
++
++/* Once-only execution */
++typedef int pthread_once_t;
++
++
++#if defined __USE_UNIX98 || defined __USE_XOPEN2K
++/* Data structure for read-write lock variable handling.  The
++   structure of the attribute type is not exposed on purpose.  */
++typedef union
++{
++# ifdef __x86_64__
++  struct
++  {
++    int __lock;
++    unsigned int __nr_readers;
++    unsigned int __readers_wakeup;
++    unsigned int __writer_wakeup;
++    unsigned int __nr_readers_queued;
++    unsigned int __nr_writers_queued;
++    int __writer;
++    int __shared;
++    unsigned long int __pad1;
++    unsigned long int __pad2;
++    /* FLAGS must stay at this position in the structure to maintain
++       binary compatibility.  */
++    unsigned int __flags;
++# define __PTHREAD_RWLOCK_INT_FLAGS_SHARED	1
++  } __data;
++# else
++  struct
++  {
++    int __lock;
++    unsigned int __nr_readers;
++    unsigned int __readers_wakeup;
++    unsigned int __writer_wakeup;
++    unsigned int __nr_readers_queued;
++    unsigned int __nr_writers_queued;
++    /* FLAGS must stay at this position in the structure to maintain
++       binary compatibility.  */
++    unsigned char __flags;
++    unsigned char __shared;
++    unsigned char __pad1;
++    unsigned char __pad2;
++    int __writer;
++  } __data;
++# endif
++  char __size[__SIZEOF_PTHREAD_RWLOCK_T];
++  long int __align;
++} pthread_rwlock_t;
++
++typedef union
++{
++  char __size[__SIZEOF_PTHREAD_RWLOCKATTR_T];
++  long int __align;
++} pthread_rwlockattr_t;
++#endif
++
++
++#ifdef __USE_XOPEN2K
++/* POSIX spinlock data type.  */
++typedef volatile int pthread_spinlock_t;
++
++
++/* POSIX barriers data type.  The structure of the type is
++   deliberately not exposed.  */
++typedef union
++{
++  char __size[__SIZEOF_PTHREAD_BARRIER_T];
++  long int __align;
++} pthread_barrier_t;
++
++typedef union
++{
++  char __size[__SIZEOF_PTHREAD_BARRIERATTR_T];
++  int __align;
++} pthread_barrierattr_t;
++#endif
++
++
++#ifndef __x86_64__
++/* Extra attributes for the cleanup functions.  */
++# define __cleanup_fct_attribute __attribute__ ((__regparm__ (1)))
++#endif
++
++#endif	/* bits/pthreadtypes.h */
+diff -urN a/nptl/sysdeps/unix/sysv/linux/x86/bits/semaphore.h b/nptl/sysdeps/unix/sysv/linux/x86/bits/semaphore.h
+--- a/nptl/sysdeps/unix/sysv/linux/x86/bits/semaphore.h	1970-01-01 01:00:00.000000000 +0100
++++ b/nptl/sysdeps/unix/sysv/linux/x86/bits/semaphore.h	2014-01-31 00:31:00.639849812 +0000
+@@ -0,0 +1,40 @@
++/* Copyright (C) 2002, 2004 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <http://www.gnu.org/licenses/>.  */
++
++#ifndef _SEMAPHORE_H
++# error "Never use <bits/semaphore.h> directly; include <semaphore.h> instead."
++#endif
++
++#include <bits/wordsize.h>
++
++#if __WORDSIZE == 64
++# define __SIZEOF_SEM_T	32
++#else
++# define __SIZEOF_SEM_T	16
++#endif
++
++
++/* Value returned if `sem_open' failed.  */
++#define SEM_FAILED      ((sem_t *) 0)
++
++
++typedef union
++{
++  char __size[__SIZEOF_SEM_T];
++  long int __align;
++} sem_t;
+diff -urN a/nptl/sysdeps/unix/sysv/linux/x86_64/Implies b/nptl/sysdeps/unix/sysv/linux/x86_64/Implies
+--- a/nptl/sysdeps/unix/sysv/linux/x86_64/Implies	1970-01-01 01:00:00.000000000 +0100
++++ b/nptl/sysdeps/unix/sysv/linux/x86_64/Implies	2014-01-31 00:31:00.639849812 +0000
+@@ -0,0 +1 @@
++unix/sysv/linux/x86
+diff -urN a/nptl/sysdeps/unix/sysv/linux/x86_64/bits/pthreadtypes.h b/nptl/sysdeps/unix/sysv/linux/x86_64/bits/pthreadtypes.h
+--- a/nptl/sysdeps/unix/sysv/linux/x86_64/bits/pthreadtypes.h	2014-01-31 00:30:29.396033346 +0000
++++ b/nptl/sysdeps/unix/sysv/linux/x86_64/bits/pthreadtypes.h	1970-01-01 01:00:00.000000000 +0100
+@@ -1,225 +0,0 @@
+-/* Copyright (C) 2002,2003,2004,2005,2006,2007 Free Software Foundation, Inc.
+-   This file is part of the GNU C Library.
+-   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
+-
+-   The GNU C Library is free software; you can redistribute it and/or
+-   modify it under the terms of the GNU Lesser General Public
+-   License as published by the Free Software Foundation; either
+-   version 2.1 of the License, or (at your option) any later version.
+-
+-   The GNU C Library is distributed in the hope that it will be useful,
+-   but WITHOUT ANY WARRANTY; without even the implied warranty of
+-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+-   Lesser General Public License for more details.
+-
+-   You should have received a copy of the GNU Lesser General Public
+-   License along with the GNU C Library; if not, write to the Free
+-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+-   02111-1307 USA.  */
+-
+-#ifndef _BITS_PTHREADTYPES_H
+-#define _BITS_PTHREADTYPES_H	1
+-
+-#include <bits/wordsize.h>
+-
+-#if __WORDSIZE == 64
+-# define __SIZEOF_PTHREAD_ATTR_T 56
+-# define __SIZEOF_PTHREAD_MUTEX_T 40
+-# define __SIZEOF_PTHREAD_MUTEXATTR_T 4
+-# define __SIZEOF_PTHREAD_COND_T 48
+-# define __SIZEOF_PTHREAD_CONDATTR_T 4
+-# define __SIZEOF_PTHREAD_RWLOCK_T 56
+-# define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
+-# define __SIZEOF_PTHREAD_BARRIER_T 32
+-# define __SIZEOF_PTHREAD_BARRIERATTR_T 4
+-#else
+-# define __SIZEOF_PTHREAD_ATTR_T 36
+-# define __SIZEOF_PTHREAD_MUTEX_T 24
+-# define __SIZEOF_PTHREAD_MUTEXATTR_T 4
+-# define __SIZEOF_PTHREAD_COND_T 48
+-# define __SIZEOF_PTHREAD_CONDATTR_T 4
+-# define __SIZEOF_PTHREAD_RWLOCK_T 32
+-# define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
+-# define __SIZEOF_PTHREAD_BARRIER_T 20
+-# define __SIZEOF_PTHREAD_BARRIERATTR_T 4
+-#endif
+-
+-
+-/* Thread identifiers.  The structure of the attribute type is not
+-   exposed on purpose.  */
+-typedef unsigned long int pthread_t;
+-
+-
+-typedef union
+-{
+-  char __size[__SIZEOF_PTHREAD_ATTR_T];
+-  long int __align;
+-} pthread_attr_t;
+-
+-
+-#if __WORDSIZE == 64
+-typedef struct __pthread_internal_list
+-{
+-  struct __pthread_internal_list *__prev;
+-  struct __pthread_internal_list *__next;
+-} __pthread_list_t;
+-#else
+-typedef struct __pthread_internal_slist
+-{
+-  struct __pthread_internal_slist *__next;
+-} __pthread_slist_t;
+-#endif
+-
+-
+-/* Data structures for mutex handling.  The structure of the attribute
+-   type is not exposed on purpose.  */
+-typedef union
+-{
+-  struct __pthread_mutex_s
+-  {
+-    int __lock;
+-    unsigned int __count;
+-    int __owner;
+-#if __WORDSIZE == 64
+-    unsigned int __nusers;
+-#endif
+-    /* KIND must stay at this position in the structure to maintain
+-       binary compatibility.  */
+-    int __kind;
+-#if __WORDSIZE == 64
+-    int __spins;
+-    __pthread_list_t __list;
+-# define __PTHREAD_MUTEX_HAVE_PREV	1
+-#else
+-    unsigned int __nusers;
+-    __extension__ union
+-    {
+-      int __spins;
+-      __pthread_slist_t __list;
+-    };
+-#endif
+-  } __data;
+-  char __size[__SIZEOF_PTHREAD_MUTEX_T];
+-  long int __align;
+-} pthread_mutex_t;
+-
+-typedef union
+-{
+-  char __size[__SIZEOF_PTHREAD_MUTEXATTR_T];
+-  int __align;
+-} pthread_mutexattr_t;
+-
+-
+-/* Data structure for conditional variable handling.  The structure of
+-   the attribute type is not exposed on purpose.  */
+-typedef union
+-{
+-  struct
+-  {
+-    int __lock;
+-    unsigned int __futex;
+-    __extension__ unsigned long long int __total_seq;
+-    __extension__ unsigned long long int __wakeup_seq;
+-    __extension__ unsigned long long int __woken_seq;
+-    void *__mutex;
+-    unsigned int __nwaiters;
+-    unsigned int __broadcast_seq;
+-  } __data;
+-  char __size[__SIZEOF_PTHREAD_COND_T];
+-  __extension__ long long int __align;
+-} pthread_cond_t;
+-
+-typedef union
+-{
+-  char __size[__SIZEOF_PTHREAD_CONDATTR_T];
+-  int __align;
+-} pthread_condattr_t;
+-
+-
+-/* Keys for thread-specific data */
+-typedef unsigned int pthread_key_t;
+-
+-
+-/* Once-only execution */
+-typedef int pthread_once_t;
+-
+-
+-#if defined __USE_UNIX98 || defined __USE_XOPEN2K
+-/* Data structure for read-write lock variable handling.  The
+-   structure of the attribute type is not exposed on purpose.  */
+-typedef union
+-{
+-# if __WORDSIZE == 64
+-  struct
+-  {
+-    int __lock;
+-    unsigned int __nr_readers;
+-    unsigned int __readers_wakeup;
+-    unsigned int __writer_wakeup;
+-    unsigned int __nr_readers_queued;
+-    unsigned int __nr_writers_queued;
+-    int __writer;
+-    int __shared;
+-    unsigned long int __pad1;
+-    unsigned long int __pad2;
+-    /* FLAGS must stay at this position in the structure to maintain
+-       binary compatibility.  */
+-    unsigned int __flags;
+-  } __data;
+-# else
+-  struct
+-  {
+-    int __lock;
+-    unsigned int __nr_readers;
+-    unsigned int __readers_wakeup;
+-    unsigned int __writer_wakeup;
+-    unsigned int __nr_readers_queued;
+-    unsigned int __nr_writers_queued;
+-    /* FLAGS must stay at this position in the structure to maintain
+-       binary compatibility.  */
+-    unsigned char __flags;
+-    unsigned char __shared;
+-    unsigned char __pad1;
+-    unsigned char __pad2;
+-    int __writer;
+-  } __data;
+-# endif
+-  char __size[__SIZEOF_PTHREAD_RWLOCK_T];
+-  long int __align;
+-} pthread_rwlock_t;
+-
+-typedef union
+-{
+-  char __size[__SIZEOF_PTHREAD_RWLOCKATTR_T];
+-  long int __align;
+-} pthread_rwlockattr_t;
+-#endif
+-
+-
+-#ifdef __USE_XOPEN2K
+-/* POSIX spinlock data type.  */
+-typedef volatile int pthread_spinlock_t;
+-
+-
+-/* POSIX barriers data type.  The structure of the type is
+-   deliberately not exposed.  */
+-typedef union
+-{
+-  char __size[__SIZEOF_PTHREAD_BARRIER_T];
+-  long int __align;
+-} pthread_barrier_t;
+-
+-typedef union
+-{
+-  char __size[__SIZEOF_PTHREAD_BARRIERATTR_T];
+-  int __align;
+-} pthread_barrierattr_t;
+-#endif
+-
+-
+-#if __WORDSIZE == 32
+-/* Extra attributes for the cleanup functions.  */
+-# define __cleanup_fct_attribute __attribute__ ((__regparm__ (1)))
+-#endif
+-
+-#endif	/* bits/pthreadtypes.h */
+diff -urN a/nptl/sysdeps/unix/sysv/linux/x86_64/bits/semaphore.h b/nptl/sysdeps/unix/sysv/linux/x86_64/bits/semaphore.h
+--- a/nptl/sysdeps/unix/sysv/linux/x86_64/bits/semaphore.h	2014-01-31 00:30:29.396033346 +0000
++++ b/nptl/sysdeps/unix/sysv/linux/x86_64/bits/semaphore.h	1970-01-01 01:00:00.000000000 +0100
+@@ -1,41 +0,0 @@
+-/* Copyright (C) 2002, 2004 Free Software Foundation, Inc.
+-   This file is part of the GNU C Library.
+-   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
+-
+-   The GNU C Library is free software; you can redistribute it and/or
+-   modify it under the terms of the GNU Lesser General Public
+-   License as published by the Free Software Foundation; either
+-   version 2.1 of the License, or (at your option) any later version.
+-
+-   The GNU C Library is distributed in the hope that it will be useful,
+-   but WITHOUT ANY WARRANTY; without even the implied warranty of
+-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+-   Lesser General Public License for more details.
+-
+-   You should have received a copy of the GNU Lesser General Public
+-   License along with the GNU C Library; if not, write to the Free
+-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+-   02111-1307 USA.  */
+-
+-#ifndef _SEMAPHORE_H
+-# error "Never use <bits/semaphore.h> directly; include <semaphore.h> instead."
+-#endif
+-
+-#include <bits/wordsize.h>
+-
+-#if __WORDSIZE == 64
+-# define __SIZEOF_SEM_T	32
+-#else
+-# define __SIZEOF_SEM_T	16
+-#endif
+-
+-
+-/* Value returned if `sem_open' failed.  */
+-#define SEM_FAILED      ((sem_t *) 0)
+-
+-
+-typedef union
+-{
+-  char __size[__SIZEOF_SEM_T];
+-  long int __align;
+-} sem_t;
diff --git a/patches/glibc/2.15/004-BZ14117-Add-x86-64-support-to-i386-sys-elf.h-and-sys-vm86.h.patch b/patches/glibc/2.15/004-BZ14117-Add-x86-64-support-to-i386-sys-elf.h-and-sys-vm86.h.patch
new file mode 100644
index 0000000..4f46869
--- /dev/null
+++ b/patches/glibc/2.15/004-BZ14117-Add-x86-64-support-to-i386-sys-elf.h-and-sys-vm86.h.patch
@@ -0,0 +1,78 @@
+From 42bbb1c314c0ba4b947b3aae433d74a90b3b58a8 Mon Sep 17 00:00:00 2001
+From: "H.J. Lu" <hjl.tools@gmail.com>
+Date: Thu, 31 May 2012 15:55:37 -0700
+Subject: [PATCH] Add x86-64 support to i386 sys/elf.h and sys/vm86.h
+
+---
+ ChangeLog                               |  7 +++++++
+ sysdeps/unix/sysv/linux/i386/sys/elf.h  | 10 +++++++---
+ sysdeps/unix/sysv/linux/i386/sys/vm86.h |  8 ++++++--
+ 3 files changed, 20 insertions(+), 5 deletions(-)
+
+diff -urN a/ChangeLog b/ChangeLog
+--- a/ChangeLog	2014-01-31 00:39:11.367438716 +0000
++++ b/ChangeLog	2014-01-31 00:40:05.781613534 +0000
+@@ -1,3 +1,10 @@
++2012-05-31  H.J. Lu  <hongjiu.lu@intel.com>
++
++       [BZ #14117]
++       * sysdeps/unix/sysv/linux/i386/sys/elf.h: Error when compiling
++       for x86-64.
++       * sysdeps/unix/sysv/linux/i386/sys/vm86.h: Likewise.
++
+ 2012-05-30  H.J. Lu  <hongjiu.lu@intel.com>
+ 
+         [BZ #14117]
+diff -urN a/sysdeps/unix/sysv/linux/i386/sys/elf.h b/sysdeps/unix/sysv/linux/i386/sys/elf.h
+--- a/sysdeps/unix/sysv/linux/i386/sys/elf.h	2014-01-31 00:39:11.434106530 +0000
++++ b/sysdeps/unix/sysv/linux/i386/sys/elf.h	2014-01-31 00:39:32.237761525 +0000
+@@ -1,4 +1,4 @@
+-/* Copyright (C) 1998, 2000 Free Software Foundation, Inc.
++/* Copyright (C) 1998-2012 Free Software Foundation, Inc.
+    This file is part of the GNU C Library.
+ 
+    The GNU C Library is free software; you can redistribute it and/or
+@@ -19,8 +19,12 @@
+ #ifndef _SYS_ELF_H
+ #define _SYS_ELF_H	1
+ 
+-#warning "This header is obsolete; use <sys/procfs.h> instead."
++#ifdef __x86_64__
++# error This header is unsupported on x86-64.
++#else
++# warning "This header is obsolete; use <sys/procfs.h> instead."
+ 
+-#include <sys/procfs.h>
++# include <sys/procfs.h>
++#endif
+ 
+ #endif	/* _SYS_ELF_H */
+diff -urN a/sysdeps/unix/sysv/linux/i386/sys/vm86.h b/sysdeps/unix/sysv/linux/i386/sys/vm86.h
+--- a/sysdeps/unix/sysv/linux/i386/sys/vm86.h	2014-01-31 00:39:11.434106530 +0000
++++ b/sysdeps/unix/sysv/linux/i386/sys/vm86.h	2014-01-31 00:39:32.237761525 +0000
+@@ -1,4 +1,4 @@
+-/* Copyright (C) 1996, 1999, 2003 Free Software Foundation, Inc.
++/* Copyright (C) 1996-2012 Free Software Foundation, Inc.
+    This file is part of the GNU C Library.
+ 
+    The GNU C Library is free software; you can redistribute it and/or
+@@ -21,8 +21,11 @@
+ #define _SYS_VM86_H	1
+ #include <features.h>
+ 
++#ifdef __x86_64__
++# error This header is unsupported on x86-64.
++#else
+ /* Get constants and data types from kernel header file.  */
+-#include <asm/vm86.h>
++# include <asm/vm86.h>
+ 
+ __BEGIN_DECLS
+ 
+@@ -31,5 +34,6 @@
+ 		 struct vm86plus_struct *__info) __THROW;
+ 
+ __END_DECLS
++# endif
+ 
+ #endif	/* _SYS_VM86_H */
diff --git a/patches/glibc/2.15/005-BZ14117-Update-x86_64-bits-stat.h.patch b/patches/glibc/2.15/005-BZ14117-Update-x86_64-bits-stat.h.patch
new file mode 100644
index 0000000..daa0143
--- /dev/null
+++ b/patches/glibc/2.15/005-BZ14117-Update-x86_64-bits-stat.h.patch
@@ -0,0 +1,64 @@
+From 67b6df7841887f676f74843ae188301b34522dc5 Mon Sep 17 00:00:00 2001
+From: "H.J. Lu" <hjl.tools@gmail.com>
+Date: Thu, 31 May 2012 16:47:45 -0700
+Subject: [PATCH] Update x86_64 bits/stat.h
+
+---
+ ChangeLog                                  | 10 ++++++++++
+ sysdeps/unix/sysv/linux/x86_64/bits/stat.h |  8 +++-----
+ 2 files changed, 13 insertions(+), 5 deletions(-)
+
+diff -urN a/ChangeLog b/ChangeLog
+--- a/ChangeLog	2014-01-31 00:41:54.529962020 +0000
++++ b/ChangeLog	2014-01-31 00:43:05.367724253 +0000
+@@ -1,6 +1,16 @@
+ 2012-05-31  H.J. Lu  <hongjiu.lu@intel.com>
+ 
+        [BZ #14117]
++       * sysdeps/unix/sysv/linux/x86_64/bits/stat.h (_STAT_VER_KERNEL):
++       Defined to 1 if __x86_64__ isn't defined.
++       (_STAT_VER_LINUX_OLD): New.
++       (st_atime): Remove duplicate.
++       (st_mtime): Likewise.
++       (st_ctime): Likewise.
++
++2012-05-31  H.J. Lu  <hongjiu.lu@intel.com>
++
++       [BZ #14117]
+        * sysdeps/unix/sysv/linux/i386/sys/elf.h: Error when compiling
+        for x86-64.
+        * sysdeps/unix/sysv/linux/i386/sys/vm86.h: Likewise.
+diff -urN a/sysdeps/unix/sysv/linux/x86_64/bits/stat.h b/sysdeps/unix/sysv/linux/x86_64/bits/stat.h
+--- a/sysdeps/unix/sysv/linux/x86_64/bits/stat.h	2014-01-31 00:41:54.589963033 +0000
++++ b/sysdeps/unix/sysv/linux/x86_64/bits/stat.h	2014-01-31 00:45:35.090039691 +0000
+@@ -24,9 +24,9 @@
+ #define _BITS_STAT_H	1
+ 
+ /* Versions of the `struct stat' data structure.  */
+-#define _STAT_VER_KERNEL	0
+-
+-#if __WORDSIZE == 32
++#ifndef __x86_64__
++# define _STAT_VER_LINUX_OLD	1
++# define _STAT_VER_KERNEL	1
+ # define _STAT_VER_SVR4		2
+ # define _STAT_VER_LINUX	3
+ 
+@@ -35,6 +35,7 @@
+ # define _MKNOD_VER_SVR4	2
+ # define _MKNOD_VER		_MKNOD_VER_LINUX /* The bits defined below.  */
+ #else
++# define _STAT_VER_KERNEL	0
+ # define _STAT_VER_LINUX	1
+ 
+ /* x86-64 versions of the `xmknod' interface.  */
+@@ -152,9 +153,6 @@
+     struct timespec st_atim;		/* Time of last access.  */
+     struct timespec st_mtim;		/* Time of last modification.  */
+     struct timespec st_ctim;		/* Time of last status change.  */
+-#  define st_atime st_atim.tv_sec	/* Backward compatibility.  */
+-#  define st_mtime st_mtim.tv_sec
+-#  define st_ctime st_ctim.tv_sec
+ # else
+     __time_t st_atime;			/* Time of last access.  */
+     unsigned long int st_atimensec;	/* Nscecs of last access.  */
diff --git a/patches/glibc/2.15/006-BZ14117-Use-x86_64-bits-typesizes.h-for-i386-and-x86-64.patch b/patches/glibc/2.15/006-BZ14117-Use-x86_64-bits-typesizes.h-for-i386-and-x86-64.patch
new file mode 100644
index 0000000..1c5b417
--- /dev/null
+++ b/patches/glibc/2.15/006-BZ14117-Use-x86_64-bits-typesizes.h-for-i386-and-x86-64.patch
@@ -0,0 +1,111 @@
+From edf2933a37d2c52b30e3730ae3df7b3d465dc958 Mon Sep 17 00:00:00 2001
+From: "H.J. Lu" <hjl.tools@gmail.com>
+Date: Thu, 31 May 2012 19:37:43 -0700
+Subject: [PATCH] Use x86_64 bits/typesizes.h for i386 and x86-64
+
+---
+ ChangeLog                                       |  4 ++
+ sysdeps/unix/sysv/linux/x86/bits/typesizes.h    | 80 +++++++++++++++++++++++++
+ sysdeps/unix/sysv/linux/x86_64/bits/typesizes.h | 80 -------------------------
+ 3 files changed, 84 insertions(+), 80 deletions(-)
+ create mode 100644 sysdeps/unix/sysv/linux/x86/bits/typesizes.h
+ delete mode 100644 sysdeps/unix/sysv/linux/x86_64/bits/typesizes.h
+
+diff -urN a/ChangeLog b/ChangeLog
+--- a/ChangeLog	2014-01-31 00:47:26.468428766 +0000
++++ b/ChangeLog	2014-01-31 00:48:44.426300964 +0000
+@@ -1,6 +1,10 @@
+ 2012-05-31  H.J. Lu  <hongjiu.lu@intel.com>
+ 
+        [BZ #14117]
++       * sysdeps/unix/sysv/linux/x86_64/bits/typesizes.h: Renamed to ...
++       * sysdeps/unix/sysv/linux/x86/bits/typesizes.h: This.
++
++       [BZ #14117]
+        * sysdeps/unix/sysv/linux/x86_64/bits/stat.h (_STAT_VER_KERNEL):
+        Defined to 1 if __x86_64__ isn't defined.
+        (_STAT_VER_LINUX_OLD): New.
+diff -urN a/sysdeps/unix/sysv/linux/x86/bits/typesizes.h b/sysdeps/unix/sysv/linux/x86/bits/typesizes.h
+--- a/sysdeps/unix/sysv/linux/x86/bits/typesizes.h	1970-01-01 01:00:00.000000000 +0100
++++ b/sysdeps/unix/sysv/linux/x86/bits/typesizes.h	2014-01-31 00:47:40.748649612 +0000
+@@ -0,0 +1,80 @@
++/* bits/typesizes.h -- underlying types for *_t.  Linux/x86-64 version.
++   Copyright (C) 2012 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <http://www.gnu.org/licenses/>.  */
++
++#ifndef _BITS_TYPES_H
++# error "Never include <bits/typesizes.h> directly; use <sys/types.h> instead."
++#endif
++
++#ifndef	_BITS_TYPESIZES_H
++#define	_BITS_TYPESIZES_H	1
++
++/* See <bits/types.h> for the meaning of these macros.  This file exists so
++   that <bits/types.h> need not vary across different GNU platforms.  */
++
++/* X32 kernel interface is 64-bit.  */
++#if defined __x86_64__ && defined __ILP32__
++# define __SYSCALL_SLONG_TYPE	__SQUAD_TYPE
++# define __SYSCALL_ULONG_TYPE	__UQUAD_TYPE
++#else
++# define __SYSCALL_SLONG_TYPE	__SLONGWORD_TYPE
++# define __SYSCALL_ULONG_TYPE	__ULONGWORD_TYPE
++#endif
++
++#define __DEV_T_TYPE		__UQUAD_TYPE
++#define __UID_T_TYPE		__U32_TYPE
++#define __GID_T_TYPE		__U32_TYPE
++#define __INO_T_TYPE		__SYSCALL_ULONG_TYPE
++#define __INO64_T_TYPE		__UQUAD_TYPE
++#define __MODE_T_TYPE		__U32_TYPE
++#ifdef __x86_64__
++# define __NLINK_T_TYPE		__SYSCALL_ULONG_TYPE
++# define __FSWORD_T_TYPE	__SYSCALL_SLONG_TYPE
++#else
++# define __NLINK_T_TYPE		__UWORD_TYPE
++# define __FSWORD_T_TYPE	__SWORD_TYPE
++#endif
++#define __OFF_T_TYPE		__SYSCALL_SLONG_TYPE
++#define __OFF64_T_TYPE		__SQUAD_TYPE
++#define __PID_T_TYPE		__S32_TYPE
++#define __RLIM_T_TYPE		__SYSCALL_ULONG_TYPE
++#define __RLIM64_T_TYPE		__UQUAD_TYPE
++#define __BLKCNT_T_TYPE		__SYSCALL_SLONG_TYPE
++#define __BLKCNT64_T_TYPE	__SQUAD_TYPE
++#define __FSBLKCNT_T_TYPE	__SYSCALL_ULONG_TYPE
++#define __FSBLKCNT64_T_TYPE	__UQUAD_TYPE
++#define __FSFILCNT_T_TYPE	__SYSCALL_ULONG_TYPE
++#define __FSFILCNT64_T_TYPE	__UQUAD_TYPE
++#define __ID_T_TYPE		__U32_TYPE
++#define __CLOCK_T_TYPE		__SYSCALL_SLONG_TYPE
++#define __TIME_T_TYPE		__SYSCALL_SLONG_TYPE
++#define __USECONDS_T_TYPE	__U32_TYPE
++#define __SUSECONDS_T_TYPE	__SYSCALL_SLONG_TYPE
++#define __DADDR_T_TYPE		__S32_TYPE
++#define __SWBLK_T_TYPE		__SYSCALL_SLONG_TYPE
++#define __KEY_T_TYPE		__S32_TYPE
++#define __CLOCKID_T_TYPE	__S32_TYPE
++#define __TIMER_T_TYPE		void *
++#define __BLKSIZE_T_TYPE	__SYSCALL_SLONG_TYPE
++#define __FSID_T_TYPE		struct { int __val[2]; }
++#define __SSIZE_T_TYPE		__SWORD_TYPE
++
++/* Number of descriptors that can fit in an `fd_set'.  */
++#define __FD_SETSIZE		1024
++
++
++#endif /* bits/typesizes.h */
diff --git a/patches/glibc/2.15/007-BZ14117-Use-i386-bits-wchar.h-for-i386-and-x86-64.patch b/patches/glibc/2.15/007-BZ14117-Use-i386-bits-wchar.h-for-i386-and-x86-64.patch
new file mode 100644
index 0000000..9769c0f
--- /dev/null
+++ b/patches/glibc/2.15/007-BZ14117-Use-i386-bits-wchar.h-for-i386-and-x86-64.patch
@@ -0,0 +1,87 @@
+From 29bcce7ce456a9fe098793784b97c7e2cd446aca Mon Sep 17 00:00:00 2001
+From: "H.J. Lu" <hjl.tools@gmail.com>
+Date: Fri, 1 Jun 2012 11:16:15 -0700
+Subject: [PATCH] Use i386 bits/wchar.h for i386 and x86-64
+
+---
+ ChangeLog                                 |  6 ++++++
+ sysdeps/unix/sysv/linux/i386/bits/wchar.h | 32 -------------------------------
+ sysdeps/unix/sysv/linux/x86/bits/wchar.h  | 32 +++++++++++++++++++++++++++++++
+ 3 files changed, 38 insertions(+), 32 deletions(-)
+ delete mode 100644 sysdeps/unix/sysv/linux/i386/bits/wchar.h
+ create mode 100644 sysdeps/unix/sysv/linux/x86/bits/wchar.h
+
+diff -urN a/ChangeLog b/ChangeLog
+--- a/ChangeLog	2014-01-31 00:57:32.091127891 +0000
++++ b/ChangeLog	2014-01-31 00:59:54.149991399 +0000
+@@ -1,6 +1,10 @@
+ 2012-05-31  H.J. Lu  <hongjiu.lu@intel.com>
+ 
+        [BZ #14117]
++       * sysdeps/unix/sysv/linux/i386/bits/wchar.h: Renamed to ...
++       * sysdeps/unix/sysv/linux/x86/bits/wchar.h: This.
++
++       [BZ #14117]
+        * sysdeps/unix/sysv/linux/x86_64/bits/typesizes.h: Renamed to ...
+        * sysdeps/unix/sysv/linux/x86/bits/typesizes.h: This.
+ 
+diff -urN a/sysdeps/unix/sysv/linux/i386/bits/wchar.h b/sysdeps/unix/sysv/linux/i386/bits/wchar.h
+--- a/sysdeps/unix/sysv/linux/i386/bits/wchar.h	2014-01-31 00:57:32.181129303 +0000
++++ b/sysdeps/unix/sysv/linux/i386/bits/wchar.h	1970-01-01 01:00:00.000000000 +0100
+@@ -1,26 +0,0 @@
+-/* wchar_t type related definitions.
+-   Copyright (C) 2000 Free Software Foundation, Inc.
+-   This file is part of the GNU C Library.
+-
+-   The GNU C Library is free software; you can redistribute it and/or
+-   modify it under the terms of the GNU Lesser General Public
+-   License as published by the Free Software Foundation; either
+-   version 2.1 of the License, or (at your option) any later version.
+-
+-   The GNU C Library is distributed in the hope that it will be useful,
+-   but WITHOUT ANY WARRANTY; without even the implied warranty of
+-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+-   Lesser General Public License for more details.
+-
+-   You should have received a copy of the GNU Lesser General Public
+-   License along with the GNU C Library; if not, write to the Free
+-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+-   02111-1307 USA.  */
+-
+-#ifndef _BITS_WCHAR_H
+-#define _BITS_WCHAR_H	1
+-
+-#define __WCHAR_MIN	(-2147483647l - 1l)
+-#define __WCHAR_MAX	(2147483647l)
+-
+-#endif	/* bits/wchar.h */
+diff -urN a/sysdeps/unix/sysv/linux/x86/bits/wchar.h b/sysdeps/unix/sysv/linux/x86/bits/wchar.h
+--- a/sysdeps/unix/sysv/linux/x86/bits/wchar.h	1970-01-01 01:00:00.000000000 +0100
++++ b/sysdeps/unix/sysv/linux/x86/bits/wchar.h	2014-01-31 00:24:17.813620271 +0000
+@@ -0,0 +1,26 @@
++/* wchar_t type related definitions.
++   Copyright (C) 2000 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#ifndef _BITS_WCHAR_H
++#define _BITS_WCHAR_H	1
++
++#define __WCHAR_MIN	(-2147483647l - 1l)
++#define __WCHAR_MAX	(2147483647l)
++
++#endif	/* bits/wchar.h */
diff --git a/patches/glibc/2.15/008-BZ14117-Define-DR_LEN_8-only-if-__x86_64__-is-defined.patch b/patches/glibc/2.15/008-BZ14117-Define-DR_LEN_8-only-if-__x86_64__-is-defined.patch
new file mode 100644
index 0000000..a1a3ee1
--- /dev/null
+++ b/patches/glibc/2.15/008-BZ14117-Define-DR_LEN_8-only-if-__x86_64__-is-defined.patch
@@ -0,0 +1,38 @@
+From 3553723f3ccc7571764b06d63a8c6e4a8f2c55bc Mon Sep 17 00:00:00 2001
+From: "H.J. Lu" <hjl.tools@gmail.com>
+Date: Fri, 1 Jun 2012 13:06:37 -0700
+Subject: [PATCH] Define DR_LEN_8 only if __x86_64__ is defined
+
+---
+ ChangeLog                                     | 6 ++++++
+ sysdeps/unix/sysv/linux/x86_64/sys/debugreg.h | 4 +++-
+ 2 files changed, 9 insertions(+), 1 deletion(-)
+
+diff -urN a/ChangeLog b/ChangeLog
+--- a/ChangeLog	2014-01-31 01:02:49.972710229 +0000
++++ b/ChangeLog	2014-01-31 01:05:01.161405973 +0000
+@@ -1,6 +1,10 @@
+ 2012-05-31  H.J. Lu  <hongjiu.lu@intel.com>
+ 
+        [BZ #14117]
++       * sysdeps/unix/sysv/linux/x86_64/sys/debugreg.h (DR_LEN_8):
++       Define only if __x86_64__ is defined.
++
++       [BZ #14117]
+        * sysdeps/unix/sysv/linux/i386/bits/wchar.h: Renamed to ...
+        * sysdeps/unix/sysv/linux/x86/bits/wchar.h: This.
+ 
+diff -urN a/sysdeps/unix/sysv/linux/x86_64/sys/debugreg.h b/sysdeps/unix/sysv/linux/x86_64/sys/debugreg.h
+--- a/sysdeps/unix/sysv/linux/x86_64/sys/debugreg.h	2014-01-31 01:02:50.036044830 +0000
++++ b/sysdeps/unix/sysv/linux/x86_64/sys/debugreg.h	2014-01-31 01:03:10.806365825 +0000
+@@ -56,7 +56,9 @@
+ #define DR_LEN_1 (0x0)	      /* Settings for data length to trap on */
+ #define DR_LEN_2 (0x4)
+ #define DR_LEN_4 (0xC)
+-#define DR_LEN_8 (0x8)
++#ifdef __x86_64__
++# define DR_LEN_8 (0x8)
++#endif
+ 
+ /* The low byte to the control register determine which registers are
+    enabled.  There are 4 fields of two bits.  One bit is "local", meaning
diff --git a/patches/glibc/2.15/009-BZ14117-Use-x86_64-bits-io-perm-.h-for-i386-and-x86_64.patch b/patches/glibc/2.15/009-BZ14117-Use-x86_64-bits-io-perm-.h-for-i386-and-x86_64.patch
new file mode 100644
index 0000000..5db600b
--- /dev/null
+++ b/patches/glibc/2.15/009-BZ14117-Use-x86_64-bits-io-perm-.h-for-i386-and-x86_64.patch
@@ -0,0 +1,718 @@
+From f3d1f93cfbbe9a0ffcab4d72e6cd8def0ca59ada Mon Sep 17 00:00:00 2001
+From: "H.J. Lu" <hjl.tools@gmail.com>
+Date: Mon, 4 Jun 2012 12:29:49 -0700
+Subject: [PATCH] Use x86_64 bits/{io,perm}.h for i386 and x86_64
+
+---
+ ChangeLog                                 |  10 ++
+ sysdeps/unix/sysv/linux/i386/sys/io.h     | 184 ------------------------------
+ sysdeps/unix/sysv/linux/i386/sys/perm.h   |  35 ------
+ sysdeps/unix/sysv/linux/x86/sys/io.h      | 183 +++++++++++++++++++++++++++++
+ sysdeps/unix/sysv/linux/x86/sys/perm.h    |  35 ++++++
+ sysdeps/unix/sysv/linux/x86_64/sys/io.h   | 183 -----------------------------
+ sysdeps/unix/sysv/linux/x86_64/sys/perm.h |  35 ------
+ 7 files changed, 228 insertions(+), 437 deletions(-)
+ delete mode 100644 sysdeps/unix/sysv/linux/i386/sys/io.h
+ delete mode 100644 sysdeps/unix/sysv/linux/i386/sys/perm.h
+ create mode 100644 sysdeps/unix/sysv/linux/x86/sys/io.h
+ create mode 100644 sysdeps/unix/sysv/linux/x86/sys/perm.h
+ delete mode 100644 sysdeps/unix/sysv/linux/x86_64/sys/io.h
+ delete mode 100644 sysdeps/unix/sysv/linux/x86_64/sys/perm.h
+
+diff -urN a/ChangeLog b/ChangeLog
+--- a/ChangeLog	2014-01-31 01:07:34.747114530 +0000
++++ b/ChangeLog	2014-01-31 01:32:27.883538690 +0000
+@@ -1,6 +1,14 @@
+ 2012-05-31  H.J. Lu  <hongjiu.lu@intel.com>
+ 
+        [BZ #14117]
++       * sysdeps/unix/sysv/linux/i386/sys/io.h: Removed.
++       * sysdeps/unix/sysv/linux/x86_64/sys/io.h: Renamed to ...
++       * sysdeps/unix/sysv/linux/x86/sys/io.h: This.
++       * sysdeps/unix/sysv/linux/i386/sys/perm.h: Removed.
++       * sysdeps/unix/sysv/linux/x86_64/sys/perm.h: Renamed to ...
++       * sysdeps/unix/sysv/linux/x86/sys/perm.h: This.
++
++       [BZ #14117]
+        * sysdeps/unix/sysv/linux/x86_64/sys/debugreg.h (DR_LEN_8):
+        Define only if __x86_64__ is defined.
+ 
+diff -urN a/sysdeps/unix/sysv/linux/i386/sys/io.h b/sysdeps/unix/sysv/linux/i386/sys/io.h
+--- a/sysdeps/unix/sysv/linux/i386/sys/io.h	2014-01-31 01:07:34.807115397 +0000
++++ b/sysdeps/unix/sysv/linux/i386/sys/io.h	1970-01-01 01:00:00.000000000 +0100
+@@ -1,185 +0,0 @@
+-/* Copyright (C) 1996, 2000, 2009 Free Software Foundation, Inc.
+-   This file is part of the GNU C Library.
+-
+-   The GNU C Library is free software; you can redistribute it and/or
+-   modify it under the terms of the GNU Lesser General Public
+-   License as published by the Free Software Foundation; either
+-   version 2.1 of the License, or (at your option) any later version.
+-
+-   The GNU C Library is distributed in the hope that it will be useful,
+-   but WITHOUT ANY WARRANTY; without even the implied warranty of
+-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+-   Lesser General Public License for more details.
+-
+-   You should have received a copy of the GNU Lesser General Public
+-   License along with the GNU C Library; if not, write to the Free
+-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+-   02111-1307 USA.  */
+-
+-#ifndef	_SYS_IO_H
+-#define	_SYS_IO_H	1
+-
+-#include <features.h>
+-
+-__BEGIN_DECLS
+-
+-/* If TURN_ON is TRUE, request for permission to do direct i/o on the
+-   port numbers in the range [FROM,FROM+NUM-1].  Otherwise, turn I/O
+-   permission off for that range.  This call requires root privileges.
+-
+-   Portability note: not all Linux platforms support this call.  Most
+-   platforms based on the PC I/O architecture probably will, however.
+-   E.g., Linux/Alpha for Alpha PCs supports this.  */
+-extern int ioperm (unsigned long int __from, unsigned long int __num,
+-                   int __turn_on) __THROW;
+-
+-/* Set the I/O privilege level to LEVEL.  If LEVEL>3, permission to
+-   access any I/O port is granted.  This call requires root
+-   privileges. */
+-extern int iopl (int __level) __THROW;
+-
+-#if defined __GNUC__ && __GNUC__ >= 2
+-
+-static __inline unsigned char
+-inb (unsigned short int __port)
+-{
+-  unsigned char _v;
+-
+-  __asm__ __volatile__ ("inb %w1,%0":"=a" (_v):"Nd" (__port));
+-  return _v;
+-}
+-
+-static __inline unsigned char
+-inb_p (unsigned short int __port)
+-{
+-  unsigned char _v;
+-
+-  __asm__ __volatile__ ("inb %w1,%0\noutb %%al,$0x80":"=a" (_v):"Nd" (__port));
+-  return _v;
+-}
+-
+-static __inline unsigned short int
+-inw (unsigned short int __port)
+-{
+-  unsigned short _v;
+-
+-  __asm__ __volatile__ ("inw %w1,%0":"=a" (_v):"Nd" (__port));
+-  return _v;
+-}
+-
+-static __inline unsigned short int
+-inw_p (unsigned short int __port)
+-{
+-  unsigned short int _v;
+-
+-  __asm__ __volatile__ ("inw %w1,%0\noutb %%al,$0x80":"=a" (_v):"Nd" (__port));
+-  return _v;
+-}
+-
+-static __inline unsigned int
+-inl (unsigned short int __port)
+-{
+-  unsigned int _v;
+-
+-  __asm__ __volatile__ ("inl %w1,%0":"=a" (_v):"Nd" (__port));
+-  return _v;
+-}
+-
+-static __inline unsigned int
+-inl_p (unsigned short int __port)
+-{
+-  unsigned int _v;
+-  __asm__ __volatile__ ("inl %w1,%0\noutb %%al,$0x80":"=a" (_v)
+-			:"Nd" (__port));
+-  return _v;
+-}
+-
+-static __inline void
+-outb (unsigned char value, unsigned short int __port)
+-{
+-  __asm__ __volatile__ ("outb %b0,%w1": :"a" (value), "Nd" (__port));
+-}
+-
+-static __inline void
+-outb_p (unsigned char value, unsigned short int __port)
+-{
+-  __asm__ __volatile__ ("outb %b0,%w1\noutb %%al,$0x80": :"a" (value),
+-			"Nd" (__port));
+-}
+-
+-static __inline void
+-outw (unsigned short int value, unsigned short int __port)
+-{
+-  __asm__ __volatile__ ("outw %w0,%w1": :"a" (value), "Nd" (__port));
+-
+-}
+-
+-static __inline void
+-outw_p (unsigned short int value, unsigned short int __port)
+-{
+-  __asm__ __volatile__ ("outw %w0,%w1\noutb %%al,$0x80": :"a" (value),
+-			"Nd" (__port));
+-}
+-
+-static __inline void
+-outl (unsigned int value, unsigned short int __port)
+-{
+-  __asm__ __volatile__ ("outl %0,%w1": :"a" (value), "Nd" (__port));
+-}
+-
+-static __inline void
+-outl_p (unsigned int value, unsigned short int __port)
+-{
+-  __asm__ __volatile__ ("outl %0,%w1\noutb %%al,$0x80": :"a" (value),
+-			"Nd" (__port));
+-}
+-
+-static __inline void
+-insb (unsigned short int __port, void *__addr, unsigned long int __count)
+-{
+-  __asm__ __volatile__ ("cld ; rep ; insb":"=D" (__addr), "=c" (__count)
+-			:"d" (__port), "0" (__addr), "1" (__count));
+-}
+-
+-static __inline void
+-insw (unsigned short int __port, void *__addr, unsigned long int __count)
+-{
+-  __asm__ __volatile__ ("cld ; rep ; insw":"=D" (__addr), "=c" (__count)
+-			:"d" (__port), "0" (__addr), "1" (__count));
+-}
+-
+-static __inline void
+-insl (unsigned short int __port, void *__addr, unsigned long int __count)
+-{
+-  __asm__ __volatile__ ("cld ; rep ; insl":"=D" (__addr), "=c" (__count)
+-			:"d" (__port), "0" (__addr), "1" (__count));
+-}
+-
+-static __inline void
+-outsb (unsigned short int __port, const void *__addr,
+-       unsigned long int __count)
+-{
+-  __asm__ __volatile__ ("cld ; rep ; outsb":"=S" (__addr), "=c" (__count)
+-			:"d" (__port), "0" (__addr), "1" (__count));
+-}
+-
+-static __inline void
+-outsw (unsigned short int __port, const void *__addr,
+-       unsigned long int __count)
+-{
+-  __asm__ __volatile__ ("cld ; rep ; outsw":"=S" (__addr), "=c" (__count)
+-			:"d" (__port), "0" (__addr), "1" (__count));
+-}
+-
+-static __inline void
+-outsl (unsigned short int __port, const void *__addr,
+-       unsigned long int __count)
+-{
+-  __asm__ __volatile__ ("cld ; rep ; outsl":"=S" (__addr), "=c" (__count)
+-			:"d" (__port), "0" (__addr), "1" (__count));
+-}
+-
+-#endif	/* GNU C */
+-
+-__END_DECLS
+-#endif /* _SYS_IO_H */
+diff -urN a/sysdeps/unix/sysv/linux/i386/sys/perm.h b/sysdeps/unix/sysv/linux/i386/sys/perm.h
+--- a/sysdeps/unix/sysv/linux/i386/sys/perm.h	2014-01-31 01:07:34.807115397 +0000
++++ b/sysdeps/unix/sysv/linux/i386/sys/perm.h	1970-01-01 01:00:00.000000000 +0100
+@@ -1,36 +0,0 @@
+-/* Copyright (C) 1996, 1999 Free Software Foundation, Inc.
+-   This file is part of the GNU C Library.
+-
+-   The GNU C Library is free software; you can redistribute it and/or
+-   modify it under the terms of the GNU Lesser General Public
+-   License as published by the Free Software Foundation; either
+-   version 2.1 of the License, or (at your option) any later version.
+-
+-   The GNU C Library is distributed in the hope that it will be useful,
+-   but WITHOUT ANY WARRANTY; without even the implied warranty of
+-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+-   Lesser General Public License for more details.
+-
+-   You should have received a copy of the GNU Lesser General Public
+-   License along with the GNU C Library; if not, write to the Free
+-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+-   02111-1307 USA.  */
+-
+-#ifndef _SYS_PERM_H
+-
+-#define _SYS_PERM_H	1
+-#include <features.h>
+-
+-__BEGIN_DECLS
+-
+-/* Set port input/output permissions.  */
+-extern int ioperm (unsigned long int __from, unsigned long int __num,
+-		   int __turn_on) __THROW;
+-
+-
+-/* Change I/O privilege level.  */
+-extern int iopl (int __level) __THROW;
+-
+-__END_DECLS
+-
+-#endif	/* _SYS_PERM_H */
+diff -urN a/sysdeps/unix/sysv/linux/x86/sys/io.h b/sysdeps/unix/sysv/linux/x86/sys/io.h
+--- a/sysdeps/unix/sysv/linux/x86/sys/io.h	1970-01-01 01:00:00.000000000 +0100
++++ b/sysdeps/unix/sysv/linux/x86/sys/io.h	2014-01-31 01:30:00.791264012 +0000
+@@ -0,0 +1,181 @@
++/* Copyright (C) 1996, 2000, 2002, 2009 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#ifndef	_SYS_IO_H
++#define	_SYS_IO_H	1
++
++#include <features.h>
++
++__BEGIN_DECLS
++
++/* If TURN_ON is TRUE, request for permission to do direct i/o on the
++   port numbers in the range [FROM,FROM+NUM-1].  Otherwise, turn I/O
++   permission off for that range.  This call requires root privileges.
++
++   Portability note: not all Linux platforms support this call.  Most
++   platforms based on the PC I/O architecture probably will, however.
++   E.g., Linux/Alpha for Alpha PCs supports this.  */
++extern int ioperm (unsigned long int __from, unsigned long int __num,
++                   int __turn_on) __THROW;
++
++/* Set the I/O privilege level to LEVEL.  If LEVEL>3, permission to
++   access any I/O port is granted.  This call requires root
++   privileges. */
++extern int iopl (int __level) __THROW;
++
++#if defined __GNUC__ && __GNUC__ >= 2
++
++static __inline unsigned char
++inb (unsigned short int __port)
++{
++  unsigned char _v;
++
++  __asm__ __volatile__ ("inb %w1,%0":"=a" (_v):"Nd" (__port));
++  return _v;
++}
++
++static __inline unsigned char
++inb_p (unsigned short int __port)
++{
++  unsigned char _v;
++
++  __asm__ __volatile__ ("inb %w1,%0\noutb %%al,$0x80":"=a" (_v):"Nd" (__port));
++  return _v;
++}
++
++static __inline unsigned short int
++inw (unsigned short int __port)
++{
++  unsigned short _v;
++
++  __asm__ __volatile__ ("inw %w1,%0":"=a" (_v):"Nd" (__port));
++  return _v;
++}
++
++static __inline unsigned short int
++inw_p (unsigned short int __port)
++{
++  unsigned short int _v;
++
++  __asm__ __volatile__ ("inw %w1,%0\noutb %%al,$0x80":"=a" (_v):"Nd" (__port));
++  return _v;
++}
++
++static __inline unsigned int
++inl (unsigned short int __port)
++{
++  unsigned int _v;
++
++  __asm__ __volatile__ ("inl %w1,%0":"=a" (_v):"Nd" (__port));
++  return _v;
++}
++
++static __inline unsigned int
++inl_p (unsigned short int __port)
++{
++  unsigned int _v;
++  __asm__ __volatile__ ("inl %w1,%0\noutb %%al,$0x80":"=a" (_v):"Nd" (__port));
++  return _v;
++}
++
++static __inline void
++outb (unsigned char __value, unsigned short int __port)
++{
++  __asm__ __volatile__ ("outb %b0,%w1": :"a" (__value), "Nd" (__port));
++}
++
++static __inline void
++outb_p (unsigned char __value, unsigned short int __port)
++{
++  __asm__ __volatile__ ("outb %b0,%w1\noutb %%al,$0x80": :"a" (__value),
++			"Nd" (__port));
++}
++
++static __inline void
++outw (unsigned short int __value, unsigned short int __port)
++{
++  __asm__ __volatile__ ("outw %w0,%w1": :"a" (__value), "Nd" (__port));
++
++}
++
++static __inline void
++outw_p (unsigned short int __value, unsigned short int __port)
++{
++  __asm__ __volatile__ ("outw %w0,%w1\noutb %%al,$0x80": :"a" (__value),
++			"Nd" (__port));
++}
++
++static __inline void
++outl (unsigned int __value, unsigned short int __port)
++{
++  __asm__ __volatile__ ("outl %0,%w1": :"a" (__value), "Nd" (__port));
++}
++
++static __inline void
++outl_p (unsigned int __value, unsigned short int __port)
++{
++  __asm__ __volatile__ ("outl %0,%w1\noutb %%al,$0x80": :"a" (__value),
++			"Nd" (__port));
++}
++
++static __inline void
++insb (unsigned short int __port, void *addr, unsigned long int __count)
++{
++  __asm__ __volatile__ ("cld ; rep ; insb":"=D" (addr), "=c" (__count)
++			:"d" (__port), "0" (addr), "1" (__count));
++}
++
++static __inline void
++insw (unsigned short int __port, void *addr, unsigned long int __count)
++{
++  __asm__ __volatile__ ("cld ; rep ; insw":"=D" (addr), "=c" (__count)
++			:"d" (__port), "0" (addr), "1" (__count));
++}
++
++static __inline void
++insl (unsigned short int __port, void *addr, unsigned long int __count)
++{
++  __asm__ __volatile__ ("cld ; rep ; insl":"=D" (addr), "=c" (__count)
++			:"d" (__port), "0" (addr), "1" (__count));
++}
++
++static __inline void
++outsb (unsigned short int __port, const void *addr, unsigned long int __count)
++{
++  __asm__ __volatile__ ("cld ; rep ; outsb":"=S" (addr), "=c" (__count)
++			:"d" (__port), "0" (addr), "1" (__count));
++}
++
++static __inline void
++outsw (unsigned short int __port, const void *addr, unsigned long int __count)
++{
++  __asm__ __volatile__ ("cld ; rep ; outsw":"=S" (addr), "=c" (__count)
++  			:"d" (__port), "0" (addr), "1" (__count));
++}
++
++static __inline void
++outsl (unsigned short int __port, const void *addr, unsigned long int __count)
++{
++  __asm__ __volatile__ ("cld ; rep ; outsl":"=S" (addr), "=c" (__count)
++			:"d" (__port), "0" (addr), "1" (__count));
++}
++
++#endif	/* GNU C */
++
++__END_DECLS
++#endif /* _SYS_IO_H */
+diff -urN a/sysdeps/unix/sysv/linux/x86/sys/perm.h b/sysdeps/unix/sysv/linux/x86/sys/perm.h
+--- a/sysdeps/unix/sysv/linux/x86/sys/perm.h	1970-01-01 01:00:00.000000000 +0100
++++ b/sysdeps/unix/sysv/linux/x86/sys/perm.h	2014-01-31 01:30:00.791264012 +0000
+@@ -0,0 +1,36 @@
++/* Copyright (C) 1996, 1999, 2001 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#ifndef _SYS_PERM_H
++
++#define _SYS_PERM_H	1
++#include <features.h>
++
++__BEGIN_DECLS
++
++/* Set port input/output permissions.  */
++extern int ioperm (unsigned long int __from, unsigned long int __num,
++		   int __turn_on) __THROW;
++
++
++/* Change I/O privilege level.  */
++extern int iopl (int __level) __THROW;
++
++__END_DECLS
++
++#endif	/* _SYS_PERM_H */
+diff -urN a/sysdeps/unix/sysv/linux/x86_64/sys/io.h b/sysdeps/unix/sysv/linux/x86_64/sys/io.h
+--- a/sysdeps/unix/sysv/linux/x86_64/sys/io.h	2014-01-31 01:07:34.807115397 +0000
++++ b/sysdeps/unix/sysv/linux/x86_64/sys/io.h	1970-01-01 01:00:00.000000000 +0100
+@@ -1,181 +0,0 @@
+-/* Copyright (C) 1996, 2000, 2002, 2009 Free Software Foundation, Inc.
+-   This file is part of the GNU C Library.
+-
+-   The GNU C Library is free software; you can redistribute it and/or
+-   modify it under the terms of the GNU Lesser General Public
+-   License as published by the Free Software Foundation; either
+-   version 2.1 of the License, or (at your option) any later version.
+-
+-   The GNU C Library is distributed in the hope that it will be useful,
+-   but WITHOUT ANY WARRANTY; without even the implied warranty of
+-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+-   Lesser General Public License for more details.
+-
+-   You should have received a copy of the GNU Lesser General Public
+-   License along with the GNU C Library; if not, write to the Free
+-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+-   02111-1307 USA.  */
+-
+-#ifndef	_SYS_IO_H
+-#define	_SYS_IO_H	1
+-
+-#include <features.h>
+-
+-__BEGIN_DECLS
+-
+-/* If TURN_ON is TRUE, request for permission to do direct i/o on the
+-   port numbers in the range [FROM,FROM+NUM-1].  Otherwise, turn I/O
+-   permission off for that range.  This call requires root privileges.
+-
+-   Portability note: not all Linux platforms support this call.  Most
+-   platforms based on the PC I/O architecture probably will, however.
+-   E.g., Linux/Alpha for Alpha PCs supports this.  */
+-extern int ioperm (unsigned long int __from, unsigned long int __num,
+-                   int __turn_on) __THROW;
+-
+-/* Set the I/O privilege level to LEVEL.  If LEVEL>3, permission to
+-   access any I/O port is granted.  This call requires root
+-   privileges. */
+-extern int iopl (int __level) __THROW;
+-
+-#if defined __GNUC__ && __GNUC__ >= 2
+-
+-static __inline unsigned char
+-inb (unsigned short int __port)
+-{
+-  unsigned char _v;
+-
+-  __asm__ __volatile__ ("inb %w1,%0":"=a" (_v):"Nd" (__port));
+-  return _v;
+-}
+-
+-static __inline unsigned char
+-inb_p (unsigned short int __port)
+-{
+-  unsigned char _v;
+-
+-  __asm__ __volatile__ ("inb %w1,%0\noutb %%al,$0x80":"=a" (_v):"Nd" (__port));
+-  return _v;
+-}
+-
+-static __inline unsigned short int
+-inw (unsigned short int __port)
+-{
+-  unsigned short _v;
+-
+-  __asm__ __volatile__ ("inw %w1,%0":"=a" (_v):"Nd" (__port));
+-  return _v;
+-}
+-
+-static __inline unsigned short int
+-inw_p (unsigned short int __port)
+-{
+-  unsigned short int _v;
+-
+-  __asm__ __volatile__ ("inw %w1,%0\noutb %%al,$0x80":"=a" (_v):"Nd" (__port));
+-  return _v;
+-}
+-
+-static __inline unsigned int
+-inl (unsigned short int __port)
+-{
+-  unsigned int _v;
+-
+-  __asm__ __volatile__ ("inl %w1,%0":"=a" (_v):"Nd" (__port));
+-  return _v;
+-}
+-
+-static __inline unsigned int
+-inl_p (unsigned short int __port)
+-{
+-  unsigned int _v;
+-  __asm__ __volatile__ ("inl %w1,%0\noutb %%al,$0x80":"=a" (_v):"Nd" (__port));
+-  return _v;
+-}
+-
+-static __inline void
+-outb (unsigned char __value, unsigned short int __port)
+-{
+-  __asm__ __volatile__ ("outb %b0,%w1": :"a" (__value), "Nd" (__port));
+-}
+-
+-static __inline void
+-outb_p (unsigned char __value, unsigned short int __port)
+-{
+-  __asm__ __volatile__ ("outb %b0,%w1\noutb %%al,$0x80": :"a" (__value),
+-			"Nd" (__port));
+-}
+-
+-static __inline void
+-outw (unsigned short int __value, unsigned short int __port)
+-{
+-  __asm__ __volatile__ ("outw %w0,%w1": :"a" (__value), "Nd" (__port));
+-
+-}
+-
+-static __inline void
+-outw_p (unsigned short int __value, unsigned short int __port)
+-{
+-  __asm__ __volatile__ ("outw %w0,%w1\noutb %%al,$0x80": :"a" (__value),
+-			"Nd" (__port));
+-}
+-
+-static __inline void
+-outl (unsigned int __value, unsigned short int __port)
+-{
+-  __asm__ __volatile__ ("outl %0,%w1": :"a" (__value), "Nd" (__port));
+-}
+-
+-static __inline void
+-outl_p (unsigned int __value, unsigned short int __port)
+-{
+-  __asm__ __volatile__ ("outl %0,%w1\noutb %%al,$0x80": :"a" (__value),
+-			"Nd" (__port));
+-}
+-
+-static __inline void
+-insb (unsigned short int __port, void *addr, unsigned long int __count)
+-{
+-  __asm__ __volatile__ ("cld ; rep ; insb":"=D" (addr), "=c" (__count)
+-			:"d" (__port), "0" (addr), "1" (__count));
+-}
+-
+-static __inline void
+-insw (unsigned short int __port, void *addr, unsigned long int __count)
+-{
+-  __asm__ __volatile__ ("cld ; rep ; insw":"=D" (addr), "=c" (__count)
+-			:"d" (__port), "0" (addr), "1" (__count));
+-}
+-
+-static __inline void
+-insl (unsigned short int __port, void *addr, unsigned long int __count)
+-{
+-  __asm__ __volatile__ ("cld ; rep ; insl":"=D" (addr), "=c" (__count)
+-			:"d" (__port), "0" (addr), "1" (__count));
+-}
+-
+-static __inline void
+-outsb (unsigned short int __port, const void *addr, unsigned long int __count)
+-{
+-  __asm__ __volatile__ ("cld ; rep ; outsb":"=S" (addr), "=c" (__count)
+-			:"d" (__port), "0" (addr), "1" (__count));
+-}
+-
+-static __inline void
+-outsw (unsigned short int __port, const void *addr, unsigned long int __count)
+-{
+-  __asm__ __volatile__ ("cld ; rep ; outsw":"=S" (addr), "=c" (__count)
+-  			:"d" (__port), "0" (addr), "1" (__count));
+-}
+-
+-static __inline void
+-outsl (unsigned short int __port, const void *addr, unsigned long int __count)
+-{
+-  __asm__ __volatile__ ("cld ; rep ; outsl":"=S" (addr), "=c" (__count)
+-			:"d" (__port), "0" (addr), "1" (__count));
+-}
+-
+-#endif	/* GNU C */
+-
+-__END_DECLS
+-#endif /* _SYS_IO_H */
+diff -urN a/sysdeps/unix/sysv/linux/x86_64/sys/perm.h b/sysdeps/unix/sysv/linux/x86_64/sys/perm.h
+--- a/sysdeps/unix/sysv/linux/x86_64/sys/perm.h	2014-01-31 01:07:34.807115397 +0000
++++ b/sysdeps/unix/sysv/linux/x86_64/sys/perm.h	1970-01-01 01:00:00.000000000 +0100
+@@ -1,36 +0,0 @@
+-/* Copyright (C) 1996, 1999, 2001 Free Software Foundation, Inc.
+-   This file is part of the GNU C Library.
+-
+-   The GNU C Library is free software; you can redistribute it and/or
+-   modify it under the terms of the GNU Lesser General Public
+-   License as published by the Free Software Foundation; either
+-   version 2.1 of the License, or (at your option) any later version.
+-
+-   The GNU C Library is distributed in the hope that it will be useful,
+-   but WITHOUT ANY WARRANTY; without even the implied warranty of
+-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+-   Lesser General Public License for more details.
+-
+-   You should have received a copy of the GNU Lesser General Public
+-   License along with the GNU C Library; if not, write to the Free
+-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+-   02111-1307 USA.  */
+-
+-#ifndef _SYS_PERM_H
+-
+-#define _SYS_PERM_H	1
+-#include <features.h>
+-
+-__BEGIN_DECLS
+-
+-/* Set port input/output permissions.  */
+-extern int ioperm (unsigned long int __from, unsigned long int __num,
+-		   int __turn_on) __THROW;
+-
+-
+-/* Change I/O privilege level.  */
+-extern int iopl (int __level) __THROW;
+-
+-__END_DECLS
+-
+-#endif	/* _SYS_PERM_H */
diff --git a/patches/glibc/2.15/010-BZ14117-Check-__SSE_MATH__-in-x86_64-feraiseexcept.patch b/patches/glibc/2.15/010-BZ14117-Check-__SSE_MATH__-in-x86_64-feraiseexcept.patch
new file mode 100644
index 0000000..abc1988
--- /dev/null
+++ b/patches/glibc/2.15/010-BZ14117-Check-__SSE_MATH__-in-x86_64-feraiseexcept.patch
@@ -0,0 +1,59 @@
+From a728a38fb658f8b2f0acbea8a586db8bd054f3fe Mon Sep 17 00:00:00 2001
+From: "H.J. Lu" <hjl.tools@gmail.com>
+Date: Wed, 6 Jun 2012 10:11:14 -0700
+Subject: [PATCH] Check __SSE_MATH__ in x86_64 feraiseexcept
+
+---
+ ChangeLog                      |  6 ++++++
+ sysdeps/x86_64/fpu/bits/fenv.h | 12 +++++++++++-
+ 2 files changed, 17 insertions(+), 1 deletion(-)
+
+diff -urN a/ChangeLog b/ChangeLog
+--- a/ChangeLog	2014-01-31 01:33:35.404582953 +0000
++++ b/ChangeLog	2014-01-31 01:35:11.996076453 +0000
+@@ -1,6 +1,10 @@
+ 2012-05-31  H.J. Lu  <hongjiu.lu@intel.com>
+ 
+        [BZ #14117]
++       * sysdeps/x86_64/fpu/bits/fenv.h (feraiseexcept): Check
++       __SSE_MATH__.
++
++       [BZ #14117]
+        * sysdeps/unix/sysv/linux/i386/sys/io.h: Removed.
+        * sysdeps/unix/sysv/linux/x86_64/sys/io.h: Renamed to ...
+        * sysdeps/unix/sysv/linux/x86/sys/io.h: This.
+diff -urN a/sysdeps/x86_64/fpu/bits/fenv.h b/sysdeps/x86_64/fpu/bits/fenv.h
+--- a/sysdeps/x86_64/fpu/bits/fenv.h	2014-01-31 01:33:35.501251115 +0000
++++ b/sysdeps/x86_64/fpu/bits/fenv.h	2014-01-31 01:36:18.607107061 +0000
+@@ -1,4 +1,4 @@
+-/* Copyright (C) 1997-2001,2004,2011 Free Software Foundation, Inc.
++/* Copyright (C) 1997-2012 Free Software Foundation, Inc.
+    This file is part of the GNU C Library.
+ 
+    The GNU C Library is free software; you can redistribute it and/or
+@@ -113,7 +113,12 @@
+ 	  /* One example of a invalid operation is 0.0 / 0.0.  */
+ 	  float __f = 0.0;
+ 
++# ifdef __SSE_MATH__
+ 	  __asm__ __volatile__ ("divss %0, %0 " : : "x" (__f));
++# else
++	  __asm__ __volatile__ ("fdiv %%st, %%st(0); fwait"
++				: "=t" (__f) : "0" (__f));
++# endif
+ 	  (void) &__f;
+ 	}
+       if ((FE_DIVBYZERO & __excepts) != 0)
+@@ -121,7 +126,12 @@
+ 	  float __f = 1.0;
+ 	  float __g = 0.0;
+ 
++# ifdef __SSE_MATH__
+ 	  __asm__ __volatile__ ("divss %1, %0" : : "x" (__f), "x" (__g));
++# else
++	  __asm__ __volatile__ ("fdivp %%st, %%st(1); fwait"
++				: "=t" (__f) : "0" (__f), "u" (__g) : "st(1)");
++# endif
+ 	  (void) &__f;
+ 	}
+ 
diff --git a/patches/glibc/2.15/011-BZ14117-Add-SSE-math-and-C-namespace-to-i386-bits-mathinline.patch b/patches/glibc/2.15/011-BZ14117-Add-SSE-math-and-C-namespace-to-i386-bits-mathinline.patch
new file mode 100644
index 0000000..228ff4e
--- /dev/null
+++ b/patches/glibc/2.15/011-BZ14117-Add-SSE-math-and-C-namespace-to-i386-bits-mathinline.patch
@@ -0,0 +1,336 @@
+From ddb28975144a7fd620ac2cae6fa219f73bd9e790 Mon Sep 17 00:00:00 2001
+From: "H.J. Lu" <hjl.tools@gmail.com>
+Date: Tue, 12 Jun 2012 11:10:40 -0700
+Subject: [PATCH] Add SSE math and C++ namespace to i386 bits/mathinline.h
+
+---
+ ChangeLog                          |  26 ++++
+ sysdeps/i386/fpu/bits/mathinline.h | 241 ++++++++++++++++++++++++++++++++++++-
+ 2 files changed, 263 insertions(+), 4 deletions(-)
+
+diff -urN a/ChangeLog b/ChangeLog
+--- a/ChangeLog	2014-01-31 01:37:49.675181880 +0000
++++ b/ChangeLog	2014-01-31 01:40:45.964574798 +0000
+@@ -1,5 +1,29 @@
+ 2012-05-31  H.J. Lu  <hongjiu.lu@intel.com>
+ 
++       [BZ #14050]
++       [BZ #14117]
++       * sysdeps/i386/fpu/bits/mathinline.h (__MATH_INLINE): Check
++       __extern_always_inline instead of __extern_inline.
++       (__signbitf): Support __SSE2_MATH__ and C++ namespace.
++       (__signbit): Likewise.
++       (__signbitl): Support C++ namespace.
++       (lrintf): New inline function.
++       (lrint): Likewise.
++       (llrintf): Likewise.
++       (llrint): Likewise.
++       (fmaxf): Likewise.
++       (fmax): Likewise.
++       (fminf): Likewise.
++       (fmin): Likewise.
++       (rint): Likewise.
++       (rintf): Likewise.
++       (ceil): Likewise.
++       (ceilf): Likewise.
++       (floor): Likewise.
++       (floorf): Likewise.
++       (nearbyint): Likewise.
++       (nearbyintf): Likewise.
++
+        [BZ #14117]
+        * sysdeps/x86_64/fpu/bits/fenv.h (feraiseexcept): Check
+        __SSE_MATH__.
+diff -urN a/sysdeps/i386/fpu/bits/mathinline.h b/sysdeps/i386/fpu/bits/mathinline.h
+--- a/sysdeps/i386/fpu/bits/mathinline.h	2014-01-31 01:37:49.751849757 +0000
++++ b/sysdeps/i386/fpu/bits/mathinline.h	2014-01-31 01:39:22.489951001 +0000
+@@ -1,8 +1,7 @@
+-/* Inline math functions for i387.
++/* Inline math functions for i387 and SSE.
+    Copyright (C) 1995,1996,1997,1998,1999,2000,2001,2003,2004,2006,2007,2009,
+    2010 Free Software Foundation, Inc.
+    This file is part of the GNU C Library.
+-   Contributed by John C. Bowman <bowman@math.ualberta.ca>, 1995.
+ 
+    The GNU C Library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+@@ -23,10 +22,10 @@
+ # error "Never use <bits/mathinline.h> directly; include <math.h> instead."
+ #endif
+ 
+-#ifndef __extern_inline
++#ifndef __extern_always_inline
+ # define __MATH_INLINE __inline
+ #else
+-# define __MATH_INLINE __extern_inline
++# define __MATH_INLINE __extern_always_inline
+ #endif
+ 
+ 
+@@ -123,18 +122,32 @@
+ /* The gcc, version 2.7 or below, has problems with all this inlining
+    code.  So disable it for this version of the compiler.  */
+ # if __GNUC_PREREQ (2, 8)
++__BEGIN_NAMESPACE_C99
++
+ /* Test for negative number.  Used in the signbit() macro.  */
+ __MATH_INLINE int
+ __NTH (__signbitf (float __x))
+ {
++#  ifdef __SSE2_MATH__
++  int __m;
++  __asm ("pmovmskb %1, %0" : "=r" (__m) : "x" (__x));
++  return (__m & 0x8) != 0;
++#  else
+   __extension__ union { float __f; int __i; } __u = { __f: __x };
+   return __u.__i < 0;
++#  endif
+ }
+ __MATH_INLINE int
+ __NTH (__signbit (double __x))
+ {
++#  ifdef __SSE2_MATH__
++  int __m;
++  __asm ("pmovmskb %1, %0" : "=r" (__m) : "x" (__x));
++  return (__m & 0x80) != 0;
++#  else
+   __extension__ union { double __d; int __i[2]; } __u = { __d: __x };
+   return __u.__i[1] < 0;
++#  endif
+ }
+ __MATH_INLINE int
+ __NTH (__signbitl (long double __x))
+@@ -142,6 +155,8 @@
+   __extension__ union { long double __l; int __i[3]; } __u = { __l: __x };
+   return (__u.__i[2] & 0x8000) != 0;
+ }
++
++__END_NAMESPACE_C99
+ # endif
+ #endif
+ 
+@@ -149,6 +164,224 @@
+ /* The gcc, version 2.7 or below, has problems with all this inlining
+    code.  So disable it for this version of the compiler.  */
+ #if __GNUC_PREREQ (2, 8)
++# if !__GNUC_PREREQ (3, 4) && !defined __NO_MATH_INLINES \
++     && defined __OPTIMIZE__
++/* GCC 3.4 introduced builtins for all functions below, so
++   there's no need to define any of these inline functions.  */
++
++#  ifdef __USE_ISOC99
++__BEGIN_NAMESPACE_C99
++
++/* Round to nearest integer.  */
++#   ifdef __SSE_MATH__
++__MATH_INLINE long int
++__NTH (lrintf (float __x))
++{
++  long int __res;
++  /* Mark as volatile since the result is dependent on the state of
++     the SSE control register (the rounding mode).  Otherwise GCC might
++     remove these assembler instructions since it does not know about
++     the rounding mode change and cannot currently be told.  */
++  __asm __volatile__ ("cvtss2si %1, %0" : "=r" (__res) : "xm" (__x));
++  return __res;
++}
++#   endif
++#   ifdef __SSE2_MATH__
++__MATH_INLINE long int
++__NTH (lrint (double __x))
++{
++  long int __res;
++  /* Mark as volatile since the result is dependent on the state of
++     the SSE control register (the rounding mode).  Otherwise GCC might
++     remove these assembler instructions since it does not know about
++     the rounding mode change and cannot currently be told.  */
++  __asm __volatile__ ("cvtsd2si %1, %0" : "=r" (__res) : "xm" (__x));
++  return __res;
++}
++#   endif
++#   ifdef __x86_64__
++__MATH_INLINE long long int
++__NTH (llrintf (float __x))
++{
++  long long int __res;
++  /* Mark as volatile since the result is dependent on the state of
++     the SSE control register (the rounding mode).  Otherwise GCC might
++     remove these assembler instructions since it does not know about
++     the rounding mode change and cannot currently be told.  */
++  __asm __volatile__ ("cvtss2si %1, %0" : "=r" (__res) : "xm" (__x));
++  return __res;
++}
++__MATH_INLINE long long int
++__NTH (llrint (double __x))
++{
++  long long int __res;
++  /* Mark as volatile since the result is dependent on the state of
++     the SSE control register (the rounding mode).  Otherwise GCC might
++     remove these assembler instructions since it does not know about
++     the rounding mode change and cannot currently be told.  */
++  __asm __volatile__ ("cvtsd2si %1, %0" : "=r" (__res) : "xm" (__x));
++  return __res;
++}
++#   endif
++
++#   if defined __FINITE_MATH_ONLY__ && __FINITE_MATH_ONLY__ > 0 \
++       && defined __SSE2_MATH__
++/* Determine maximum of two values.  */
++__MATH_INLINE float
++__NTH (fmaxf (float __x, float __y))
++{
++#    ifdef __AVX__
++  float __res;
++  __asm ("vmaxss %2, %1, %0" : "=x" (__res) : "x" (x), "xm" (__y));
++  return __res;
++#    else
++  __asm ("maxss %1, %0" : "+x" (__x) : "xm" (__y));
++  return __x;
++#    endif
++}
++__MATH_INLINE double
++__NTH (fmax (double __x, double __y))
++{
++#    ifdef __AVX__
++  float __res;
++  __asm ("vmaxsd %2, %1, %0" : "=x" (__res) : "x" (x), "xm" (__y));
++  return __res;
++#    else
++  __asm ("maxsd %1, %0" : "+x" (__x) : "xm" (__y));
++  return __x;
++#    endif
++}
++
++/* Determine minimum of two values.  */
++__MATH_INLINE float
++__NTH (fminf (float __x, float __y))
++{
++#    ifdef __AVX__
++  float __res;
++  __asm ("vminss %2, %1, %0" : "=x" (__res) : "x" (x), "xm" (__y));
++  return __res;
++#    else
++  __asm ("minss %1, %0" : "+x" (__x) : "xm" (__y));
++  return __x;
++#    endif
++}
++__MATH_INLINE double
++__NTH (fmin (double __x, double __y))
++{
++#    ifdef __AVX__
++  float __res;
++  __asm ("vminsd %2, %1, %0" : "=x" (__res) : "x" (x), "xm" (__y));
++  return __res;
++#    else
++  __asm ("minsd %1, %0" : "+x" (__x) : "xm" (__y));
++  return __x;
++#    endif
++}
++#   endif
++
++__END_NAMESPACE_C99
++#  endif
++
++#  if defined __SSE4_1__ && defined __SSE2_MATH__
++#   if defined __USE_MISC || defined __USE_XOPEN_EXTENDED || defined __USE_ISOC99
++__BEGIN_NAMESPACE_C99
++
++/* Round to nearest integer.  */
++__MATH_INLINE double
++__NTH (rint (double __x))
++{
++  double __res;
++  /* Mark as volatile since the result is dependent on the state of
++     the SSE control register (the rounding mode).  Otherwise GCC might
++     remove these assembler instructions since it does not know about
++     the rounding mode change and cannot currently be told.  */
++  __asm __volatile__ ("roundsd $4, %1, %0" : "=x" (__res) : "xm" (__x));
++  return __res;
++}
++__MATH_INLINE float
++__NTH (rintf (float __x))
++{
++  float __res;
++  /* Mark as volatile since the result is dependent on the state of
++     the SSE control register (the rounding mode).  Otherwise GCC might
++     remove these assembler instructions since it does not know about
++     the rounding mode change and cannot currently be told.  */
++  __asm __volatile__ ("roundss $4, %1, %0" : "=x" (__res) : "xm" (__x));
++  return __res;
++}
++
++#    ifdef __USE_ISOC99
++/* Round to nearest integer without raising inexact exception.  */
++__MATH_INLINE double
++__NTH (nearbyint (double __x))
++{
++  double __res;
++  /* Mark as volatile since the result is dependent on the state of
++     the SSE control register (the rounding mode).  Otherwise GCC might
++     remove these assembler instructions since it does not know about
++     the rounding mode change and cannot currently be told.  */
++  __asm __volatile__ ("roundsd $0xc, %1, %0" : "=x" (__res) : "xm" (__x));
++  return __res;
++}
++__MATH_INLINE float
++__NTH (nearbyintf (float __x))
++{
++  float __res;
++  /* Mark as volatile since the result is dependent on the state of
++     the SSE control register (the rounding mode).  Otherwise GCC might
++     remove these assembler instructions since it does not know about
++     the rounding mode change and cannot currently be told.  */
++  __asm __volatile__ ("roundss $0xc, %1, %0" : "=x" (__res) : "xm" (__x));
++  return __res;
++}
++#    endif
++
++__END_NAMESPACE_C99
++#   endif
++
++__BEGIN_NAMESPACE_STD
++/* Smallest integral value not less than X.  */
++__MATH_INLINE double
++__NTH (ceil (double __x))
++{
++  double __res;
++  __asm ("roundsd $2, %1, %0" : "=x" (__res) : "xm" (__x));
++  return __res;
++}
++__END_NAMESPACE_STD
++
++__BEGIN_NAMESPACE_C99
++__MATH_INLINE float
++__NTH (ceilf (float __x))
++{
++  float __res;
++  __asm ("roundss $2, %1, %0" : "=x" (__res) : "xm" (__x));
++  return __res;
++}
++__END_NAMESPACE_C99
++
++__BEGIN_NAMESPACE_STD
++/* Largest integer not greater than X.  */
++__MATH_INLINE double
++__NTH (floor (double __x))
++{
++  double __res;
++  __asm ("roundsd $1, %1, %0" : "=x" (__res) : "xm" (__x));
++  return __res;
++}
++__END_NAMESPACE_STD
++
++__BEGIN_NAMESPACE_C99
++__MATH_INLINE float
++__NTH (floorf (float __x))
++{
++  float __res;
++  __asm ("roundss $1, %1, %0" : "=x" (__res) : "xm" (__x));
++  return __res;
++}
++__END_NAMESPACE_C99
++#  endif
++# endif
+ 
+ #if ((!defined __NO_MATH_INLINES || defined __LIBC_INTERNAL_MATH_INLINES) \
+      && defined __OPTIMIZE__)
diff --git a/patches/glibc/2.15/012-BZ14117-Disable-x87-inline-functions-for-x86-64.patch b/patches/glibc/2.15/012-BZ14117-Disable-x87-inline-functions-for-x86-64.patch
new file mode 100644
index 0000000..4c5bd3f
--- /dev/null
+++ b/patches/glibc/2.15/012-BZ14117-Disable-x87-inline-functions-for-x86-64.patch
@@ -0,0 +1,441 @@
+From ed1825f858842b102f735b129ca1e569e2247809 Mon Sep 17 00:00:00 2001
+From: "H.J. Lu" <hjl.tools@gmail.com>
+Date: Fri, 15 Jun 2012 06:52:47 -0700
+Subject: [PATCH] Disable x87 inline functions for x86-64
+
+---
+ ChangeLog                          |   7 +
+ sysdeps/i386/fpu/bits/mathinline.h | 254 +++++++++++++++++++------------------
+ 2 files changed, 135 insertions(+), 126 deletions(-)
+
+diff -urN a/ChangeLog b/ChangeLog
+--- a/ChangeLog	2014-01-31 01:42:13.052588275 +0000
++++ b/ChangeLog	2014-01-31 01:43:18.593601692 +0000
+@@ -2,6 +2,11 @@
+ 
+        [BZ #14050]
+        [BZ #14117]
++       * sysdeps/i386/fpu/bits/mathinline.h: Disable x87 inline
++       functions if __x86_64__ is defined.
++
++       [BZ #14050]
++       [BZ #14117]
+        * sysdeps/i386/fpu/bits/mathinline.h (__MATH_INLINE): Check
+        __extern_always_inline instead of __extern_inline.
+        (__signbitf): Support __SSE2_MATH__ and C++ namespace.
+diff -urN a/sysdeps/i386/fpu/bits/mathinline.h b/sysdeps/i386/fpu/bits/mathinline.h
+--- a/sysdeps/i386/fpu/bits/mathinline.h	2014-01-31 01:42:13.122589322 +0000
++++ b/sysdeps/i386/fpu/bits/mathinline.h	2014-01-31 01:42:27.639480433 +0000
+@@ -382,13 +382,15 @@
+ __END_NAMESPACE_C99
+ #  endif
+ # endif
++#endif
+ 
+-#if ((!defined __NO_MATH_INLINES || defined __LIBC_INTERNAL_MATH_INLINES) \
++#ifndef __x86_64__
++# if ((!defined __NO_MATH_INLINES || defined __LIBC_INTERNAL_MATH_INLINES) \
+      && defined __OPTIMIZE__)
+ 
+ /* The inline functions do not set errno or raise necessarily the
+    correct exceptions.  */
+-# undef math_errhandling
++#  undef math_errhandling
+ 
+ /* A macro to define float, double, and long double versions of various
+    math functions for the ix87 FPU.  FUNC is the function name (which will
+@@ -397,49 +399,49 @@
+    We define two sets of macros.  The set with the additional NP
+    doesn't add a prototype declaration.  */
+ 
+-#if defined __USE_MISC || defined __USE_ISOC99
+-# define __inline_mathop(func, op) \
++#  if defined __USE_MISC || defined __USE_ISOC99
++#   define __inline_mathop(func, op) \
+   __inline_mathop_ (double, func, op)					      \
+   __inline_mathop_ (float, __CONCAT(func,f), op)			      \
+   __inline_mathop_ (long double, __CONCAT(func,l), op)
+-# define __inline_mathopNP(func, op) \
++#   define __inline_mathopNP(func, op) \
+   __inline_mathopNP_ (double, func, op)					      \
+   __inline_mathopNP_ (float, __CONCAT(func,f), op)			      \
+   __inline_mathopNP_ (long double, __CONCAT(func,l), op)
+-#else
+-# define __inline_mathop(func, op) \
++#  else
++#   define __inline_mathop(func, op) \
+   __inline_mathop_ (double, func, op)
+-# define __inline_mathopNP(func, op) \
++#   define __inline_mathopNP(func, op) \
+   __inline_mathopNP_ (double, func, op)
+-#endif
++#  endif
+ 
+-#define __inline_mathop_(float_type, func, op) \
++#  define __inline_mathop_(float_type, func, op) \
+   __inline_mathop_decl_ (float_type, func, op, "0" (__x))
+-#define __inline_mathopNP_(float_type, func, op) \
++#  define __inline_mathopNP_(float_type, func, op) \
+   __inline_mathop_declNP_ (float_type, func, op, "0" (__x))
+ 
+ 
+-#if defined __USE_MISC || defined __USE_ISOC99
+-# define __inline_mathop_decl(func, op, params...) \
++#  if defined __USE_MISC || defined __USE_ISOC99
++#   define __inline_mathop_decl(func, op, params...) \
+   __inline_mathop_decl_ (double, func, op, params)			      \
+   __inline_mathop_decl_ (float, __CONCAT(func,f), op, params)		      \
+   __inline_mathop_decl_ (long double, __CONCAT(func,l), op, params)
+-# define __inline_mathop_declNP(func, op, params...) \
++#   define __inline_mathop_declNP(func, op, params...) \
+   __inline_mathop_declNP_ (double, func, op, params)			      \
+   __inline_mathop_declNP_ (float, __CONCAT(func,f), op, params)		      \
+   __inline_mathop_declNP_ (long double, __CONCAT(func,l), op, params)
+-#else
+-# define __inline_mathop_decl(func, op, params...) \
++#  else
++#   define __inline_mathop_decl(func, op, params...) \
+   __inline_mathop_decl_ (double, func, op, params)
+-# define __inline_mathop_declNP(func, op, params...) \
++#   define __inline_mathop_declNP(func, op, params...) \
+   __inline_mathop_declNP_ (double, func, op, params)
+-#endif
++#  endif
+ 
+-#define __inline_mathop_decl_(float_type, func, op, params...) \
++#  define __inline_mathop_decl_(float_type, func, op, params...) \
+   __MATH_INLINE float_type func (float_type) __THROW;			      \
+   __inline_mathop_declNP_ (float_type, func, op, params)
+ 
+-#define __inline_mathop_declNP_(float_type, func, op, params...) \
++#  define __inline_mathop_declNP_(float_type, func, op, params...) \
+   __MATH_INLINE float_type __NTH (func (float_type __x))		      \
+   {									      \
+     register float_type __result;					      \
+@@ -594,19 +596,19 @@
+ {
+   __sincos_code;
+ }
+-# endif
++#   endif
+ 
+ 
+ /* Optimized inline implementation, sometimes with reduced precision
+    and/or argument range.  */
+ 
+-# if __GNUC_PREREQ (3, 5)
+-#  define __expm1_code \
++#   if __GNUC_PREREQ (3, 5)
++#    define __expm1_code \
+   register long double __temp;						      \
+   __temp = __builtin_expm1l (__x);					      \
+   return __temp ? __temp : __x
+-# else
+-#  define __expm1_code \
++#   else
++#    define __expm1_code \
+   register long double __value;						      \
+   register long double __exponent;					      \
+   register long double __temp;						      \
+@@ -626,13 +628,13 @@
+   __temp -= 1.0;							      \
+   __temp += __value;							      \
+   return __temp ? __temp : __x
+-# endif
++#   endif
+ __inline_mathcodeNP_ (long double, __expm1l, __x, __expm1_code)
+ 
+-# if __GNUC_PREREQ (3, 4)
++#   if __GNUC_PREREQ (3, 4)
+ __inline_mathcodeNP_ (long double, __expl, __x, return __builtin_expl (__x))
+-# else
+-#  define __exp_code \
++#   else
++#    define __exp_code \
+   register long double __value;						      \
+   register long double __exponent;					      \
+   __asm __volatile__							      \
+@@ -651,10 +653,10 @@
+   return __value
+ __inline_mathcodeNP (exp, __x, __exp_code)
+ __inline_mathcodeNP_ (long double, __expl, __x, __exp_code)
+-# endif
++#   endif
+ 
+ 
+-# if !__GNUC_PREREQ (3, 5)
++#   if !__GNUC_PREREQ (3, 5)
+ __inline_mathcodeNP (tan, __x, \
+   register long double __value;						      \
+   register long double __value2 __attribute__ ((__unused__));		      \
+@@ -662,28 +664,28 @@
+     ("fptan"								      \
+      : "=t" (__value2), "=u" (__value) : "0" (__x));			      \
+   return __value)
+-# endif
+-#endif /* __FAST_MATH__ */
++#   endif
++#  endif /* __FAST_MATH__ */
+ 
+ 
+-#if __GNUC_PREREQ (3, 4)
++#  if __GNUC_PREREQ (3, 4)
+ __inline_mathcodeNP2_ (long double, __atan2l, __y, __x,
+ 		       return __builtin_atan2l (__y, __x))
+-#else
+-# define __atan2_code \
++#  else
++#   define __atan2_code \
+   register long double __value;						      \
+   __asm __volatile__							      \
+     ("fpatan"								      \
+      : "=t" (__value) : "0" (__x), "u" (__y) : "st(1)");		      \
+   return __value
+-# ifdef __FAST_MATH__
++#   ifdef __FAST_MATH__
+ __inline_mathcodeNP2 (atan2, __y, __x, __atan2_code)
+-# endif
++#   endif
+ __inline_mathcodeNP2_ (long double, __atan2l, __y, __x, __atan2_code)
+-#endif
++#  endif
+ 
+ 
+-#if defined __FAST_MATH__ && !__GNUC_PREREQ (3, 5)
++#  if defined __FAST_MATH__ && !__GNUC_PREREQ (3, 5)
+ __inline_mathcodeNP2 (fmod, __x, __y, \
+   register long double __value;						      \
+   __asm __volatile__							      \
+@@ -693,52 +695,52 @@
+      "jp	1b"							      \
+      : "=t" (__value) : "0" (__x), "u" (__y) : "ax", "cc");		      \
+   return __value)
+-#endif
++#  endif
+ 
+ 
+-#ifdef __FAST_MATH__
+-# if !__GNUC_PREREQ (3,3)
++#  ifdef __FAST_MATH__
++#   if !__GNUC_PREREQ (3,3)
+ __inline_mathopNP (sqrt, "fsqrt")
+ __inline_mathopNP_ (long double, __sqrtl, "fsqrt")
+-#  define __libc_sqrtl(n) __sqrtl (n)
+-# else
+-#  define __libc_sqrtl(n) __builtin_sqrtl (n)
+-# endif
+-#endif
++#    define __libc_sqrtl(n) __sqrtl (n)
++#   else
++#    define __libc_sqrtl(n) __builtin_sqrtl (n)
++#   endif
++#  endif
+ 
+-#if __GNUC_PREREQ (2, 8)
++#  if __GNUC_PREREQ (2, 8)
+ __inline_mathcodeNP_ (double, fabs, __x, return __builtin_fabs (__x))
+-# if defined __USE_MISC || defined __USE_ISOC99
++#   if defined __USE_MISC || defined __USE_ISOC99
+ __inline_mathcodeNP_ (float, fabsf, __x, return __builtin_fabsf (__x))
+ __inline_mathcodeNP_ (long double, fabsl, __x, return __builtin_fabsl (__x))
+-# endif
++#   endif
+ __inline_mathcodeNP_ (long double, __fabsl, __x, return __builtin_fabsl (__x))
+-#else
++#  else
+ __inline_mathop (fabs, "fabs")
+ __inline_mathop_ (long double, __fabsl, "fabs")
+-#endif
++# endif
+ 
+-#ifdef __FAST_MATH__
+-# if !__GNUC_PREREQ (3, 4)
++#  ifdef __FAST_MATH__
++#   if !__GNUC_PREREQ (3, 4)
+ /* The argument range of this inline version is reduced.  */
+ __inline_mathopNP (sin, "fsin")
+ /* The argument range of this inline version is reduced.  */
+ __inline_mathopNP (cos, "fcos")
+ 
+ __inline_mathop_declNP (log, "fldln2; fxch; fyl2x", "0" (__x) : "st(1)")
+-# endif
++#   endif
+ 
+-# if !__GNUC_PREREQ (3, 5)
++#   if !__GNUC_PREREQ (3, 5)
+ __inline_mathop_declNP (log10, "fldlg2; fxch; fyl2x", "0" (__x) : "st(1)")
+ 
+ __inline_mathcodeNP (asin, __x, return __atan2l (__x, __libc_sqrtl (1.0 - __x * __x)))
+ __inline_mathcodeNP (acos, __x, return __atan2l (__libc_sqrtl (1.0 - __x * __x), __x))
+-# endif
++#   endif
+ 
+-# if !__GNUC_PREREQ (3, 4)
++#   if !__GNUC_PREREQ (3, 4)
+ __inline_mathop_declNP (atan, "fld1; fpatan", "0" (__x) : "st(1)")
+-# endif
+-#endif /* __FAST_MATH__ */
++#   endif
++#  endif /* __FAST_MATH__ */
+ 
+ __inline_mathcode_ (long double, __sgn1l, __x, \
+   __extension__ union { long double __xld; unsigned int __xi[3]; } __n =      \
+@@ -749,7 +751,7 @@
+   return __n.__xld)
+ 
+ 
+-#ifdef __FAST_MATH__
++#  ifdef __FAST_MATH__
+ /* The argument range of the inline version of sinhl is slightly reduced.  */
+ __inline_mathcodeNP (sinh, __x, \
+   register long double __exm1 = __expm1l (__fabsl (__x));		      \
+@@ -762,7 +764,7 @@
+ __inline_mathcodeNP (tanh, __x, \
+   register long double __exm1 = __expm1l (-__fabsl (__x + __x));	      \
+   return __exm1 / (__exm1 + 2.0) * __sgn1l (-__x))
+-#endif
++#  endif
+ 
+ __inline_mathcodeNP (floor, __x, \
+   register long double __value;						      \
+@@ -800,8 +802,8 @@
+ 		    : "0" (__x));					      \
+   return __value)
+ 
+-#ifdef __FAST_MATH__
+-# define __ldexp_code \
++#  ifdef __FAST_MATH__
++#   define __ldexp_code \
+   register long double __value;						      \
+   __asm __volatile__							      \
+     ("fscale"								      \
+@@ -813,20 +815,20 @@
+ {
+   __ldexp_code;
+ }
+-#endif
++#  endif
+ 
+ 
+ /* Optimized versions for some non-standardized functions.  */
+-#if defined __USE_ISOC99 || defined __USE_MISC
++#  if defined __USE_ISOC99 || defined __USE_MISC
+ 
+-# ifdef __FAST_MATH__
++#   ifdef __FAST_MATH__
+ __inline_mathcodeNP (expm1, __x, __expm1_code)
+ 
+ /* We cannot rely on M_SQRT being defined.  So we do it for ourself
+    here.  */
+-#  define __M_SQRT2	1.41421356237309504880L	/* sqrt(2) */
++#    define __M_SQRT2	1.41421356237309504880L	/* sqrt(2) */
+ 
+-#  if !__GNUC_PREREQ (3, 5)
++#    if !__GNUC_PREREQ (3, 5)
+ __inline_mathcodeNP (log1p, __x, \
+   register long double __value;						      \
+   if (__fabsl (__x) >= 1.0 - 0.5 * __M_SQRT2)				      \
+@@ -838,7 +840,7 @@
+        "fyl2xp1"							      \
+        : "=t" (__value) : "0" (__x) : "st(1)");				      \
+   return __value)
+-#  endif
++#    endif
+ 
+ 
+ /* The argument range of the inline version of asinhl is slightly reduced.  */
+@@ -858,7 +860,7 @@
+ __inline_mathcodeNP2 (hypot, __x, __y,
+ 		      return __libc_sqrtl (__x * __x + __y * __y))
+ 
+-#  if !__GNUC_PREREQ (3, 5)
++#    if !__GNUC_PREREQ (3, 5)
+ __inline_mathcodeNP(logb, __x, \
+   register long double __value;						      \
+   register long double __junk;						      \
+@@ -866,17 +868,17 @@
+     ("fxtract\n\t"							      \
+      : "=t" (__junk), "=u" (__value) : "0" (__x));			      \
+   return __value)
++#    endif
++
++#   endif
+ #  endif
+ 
+-# endif
+-#endif
++#  ifdef __USE_ISOC99
++#   ifdef __FAST_MATH__
+ 
+-#ifdef __USE_ISOC99
+-# ifdef __FAST_MATH__
+-
+-#  if !__GNUC_PREREQ (3, 5)
++#    if !__GNUC_PREREQ (3, 5)
+ __inline_mathop_declNP (log2, "fld1; fxch; fyl2x", "0" (__x) : "st(1)")
+-#  endif
++#    endif
+ 
+ __MATH_INLINE float
+ __NTH (ldexpf (float __x, int __y))
+@@ -891,9 +893,9 @@
+ }
+ 
+ __inline_mathopNP (rint, "frndint")
+-# endif /* __FAST_MATH__ */
++#   endif /* __FAST_MATH__ */
+ 
+-# define __lrint_code \
++#   define __lrint_code \
+   long int __lrintres;							      \
+   __asm__ __volatile__							      \
+     ("fistpl %0"							      \
+@@ -914,9 +916,9 @@
+ {
+   __lrint_code;
+ }
+-# undef __lrint_code
++#   undef __lrint_code
+ 
+-# define __llrint_code \
++#   define __llrint_code \
+   long long int __llrintres;						      \
+   __asm__ __volatile__							      \
+     ("fistpll %0"							      \
+@@ -937,14 +939,14 @@
+ {
+   __llrint_code;
+ }
+-# undef __llrint_code
++#   undef __llrint_code
+ 
+-#endif
++# endif
+ 
+ 
+-#ifdef __USE_MISC
++#  ifdef __USE_MISC
+ 
+-# if defined __FAST_MATH__ && !__GNUC_PREREQ (3, 5)
++#   if defined __FAST_MATH__ && !__GNUC_PREREQ (3, 5)
+ __inline_mathcodeNP2 (drem, __x, __y, \
+   register double __value;						      \
+   register int __clobbered;						      \
+@@ -955,7 +957,7 @@
+      "jp	1b"							      \
+      : "=t" (__value), "=&a" (__clobbered) : "0" (__x), "u" (__y) : "cc");    \
+   return __value)
+-# endif
++#  endif
+ 
+ 
+ /* This function is used in the `isfinite' macro.  */
+@@ -999,6 +1001,6 @@
+ 					: "=t" (__value)
+ 					: "0" (__x), "u" (__y) : "st(1)");
+ 		    return __value;)
+-#endif
++# endif
+ 
+-#endif /* __GNUC__  */
++#endif /* !__x86_64__ */
diff --git a/patches/glibc/2.15/013-BZ14117-Use-i386-bits-mathinline.h-for-i386-and-x86_64.patch b/patches/glibc/2.15/013-BZ14117-Use-i386-bits-mathinline.h-for-i386-and-x86_64.patch
new file mode 100644
index 0000000..1a4634e
--- /dev/null
+++ b/patches/glibc/2.15/013-BZ14117-Use-i386-bits-mathinline.h-for-i386-and-x86_64.patch
@@ -0,0 +1,2255 @@
+From 25f1282ae5072ccf586f041356ddde02f069c4ff Mon Sep 17 00:00:00 2001
+From: "H.J. Lu" <hjl.tools@gmail.com>
+Date: Fri, 15 Jun 2012 13:56:26 -0700
+Subject: [PATCH] Use i386 bits/mathinline.h for i386 and x86_64
+
+---
+ ChangeLog                            |   5 +
+ sysdeps/i386/fpu/bits/mathinline.h   | 968 -----------------------------------
+ sysdeps/x86/fpu/bits/mathinline.h    | 968 +++++++++++++++++++++++++++++++++++
+ sysdeps/x86_64/fpu/bits/mathinline.h | 289 -----------
+ 4 files changed, 973 insertions(+), 1257 deletions(-)
+ delete mode 100644 sysdeps/i386/fpu/bits/mathinline.h
+ create mode 100644 sysdeps/x86/fpu/bits/mathinline.h
+ delete mode 100644 sysdeps/x86_64/fpu/bits/mathinline.h
+
+diff -urN a/ChangeLog b/ChangeLog
+--- a/ChangeLog	2014-01-31 12:35:27.554508313 +0000
++++ b/ChangeLog	2014-01-31 12:34:14.551174223 +0000
+@@ -1,5 +1,16 @@
++2014-01-31  Ray Donnelly <mingw.android@gmail.com>
++
++       [BZ #14117]
++       * Copied sysdeps/x85/fpu/bits/mathinline.h from
++       glibc-2.16 as it has fixes for SSE clobbering.
++
+ 2012-05-31  H.J. Lu  <hongjiu.lu@intel.com>
+ 
++       [BZ #14117]
++       * sysdeps/i386/fpu/bits/mathinline.h: Renamed to ...
++       * sysdeps/x86/fpu/bits/mathinline.h: This.
++       * sysdeps/x86_64/fpu/bits/mathinline.h: Removed.
++
+        [BZ #14050]
+        [BZ #14117]
+        * sysdeps/i386/fpu/bits/mathinline.h: Disable x87 inline
+diff -urN a/sysdeps/i386/fpu/bits/mathinline.h b/sysdeps/i386/fpu/bits/mathinline.h
+--- a/sysdeps/i386/fpu/bits/mathinline.h	2014-01-31 12:35:27.554508313 +0000
++++ b/sysdeps/i386/fpu/bits/mathinline.h	1970-01-01 00:00:00.000000000 +0000
+@@ -1,1006 +0,0 @@
+-/* Inline math functions for i387 and SSE.
+-   Copyright (C) 1995,1996,1997,1998,1999,2000,2001,2003,2004,2006,2007,2009,
+-   2010 Free Software Foundation, Inc.
+-   This file is part of the GNU C Library.
+-
+-   The GNU C Library is free software; you can redistribute it and/or
+-   modify it under the terms of the GNU Lesser General Public
+-   License as published by the Free Software Foundation; either
+-   version 2.1 of the License, or (at your option) any later version.
+-
+-   The GNU C Library is distributed in the hope that it will be useful,
+-   but WITHOUT ANY WARRANTY; without even the implied warranty of
+-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+-   Lesser General Public License for more details.
+-
+-   You should have received a copy of the GNU Lesser General Public
+-   License along with the GNU C Library; if not, write to the Free
+-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+-   02111-1307 USA.  */
+-
+-#ifndef _MATH_H
+-# error "Never use <bits/mathinline.h> directly; include <math.h> instead."
+-#endif
+-
+-#ifndef __extern_always_inline
+-# define __MATH_INLINE __inline
+-#else
+-# define __MATH_INLINE __extern_always_inline
+-#endif
+-
+-
+-#if defined __USE_ISOC99 && defined __GNUC__ && __GNUC__ >= 2
+-/* GCC 2.97 and up have builtins that actually can be used.  */
+-# if !__GNUC_PREREQ (2,97)
+-/* ISO C99 defines some macros to perform unordered comparisons.  The
+-   ix87 FPU supports this with special opcodes and we should use them.
+-   These must not be inline functions since we have to be able to handle
+-   all floating-point types.  */
+-#  undef isgreater
+-#  undef isgreaterequal
+-#  undef isless
+-#  undef islessequal
+-#  undef islessgreater
+-#  undef isunordered
+-#  ifdef __i686__
+-/* For the PentiumPro and more recent processors we can provide
+-   better code.  */
+-#   define isgreater(x, y) \
+-     ({ register char __result;						      \
+-	__asm__ ("fucomip %%st(1), %%st; seta %%al"			      \
+-		 : "=a" (__result) : "u" (y), "t" (x) : "cc", "st");	      \
+-	__result; })
+-#   define isgreaterequal(x, y) \
+-     ({ register char __result;						      \
+-	__asm__ ("fucomip %%st(1), %%st; setae %%al"			      \
+-		 : "=a" (__result) : "u" (y), "t" (x) : "cc", "st");	      \
+-	__result; })
+-
+-#   define isless(x, y) \
+-     ({ register char __result;						      \
+-	__asm__ ("fucomip %%st(1), %%st; seta %%al"			      \
+-		 : "=a" (__result) : "u" (x), "t" (y) : "cc", "st");	      \
+-	__result; })
+-
+-#   define islessequal(x, y) \
+-     ({ register char __result;						      \
+-	__asm__ ("fucomip %%st(1), %%st; setae %%al"			      \
+-		 : "=a" (__result) : "u" (x), "t" (y) : "cc", "st");	      \
+-	__result; })
+-
+-#   define islessgreater(x, y) \
+-     ({ register char __result;						      \
+-	__asm__ ("fucomip %%st(1), %%st; setne %%al"			      \
+-		 : "=a" (__result) : "u" (y), "t" (x) : "cc", "st");	      \
+-	__result; })
+-
+-#   define isunordered(x, y) \
+-     ({ register char __result;						      \
+-	__asm__ ("fucomip %%st(1), %%st; setp %%al"			      \
+-		 : "=a" (__result) : "u" (y), "t" (x) : "cc", "st");	      \
+-	__result; })
+-#  else
+-/* This is the dumb, portable code for i386 and above.  */
+-#   define isgreater(x, y) \
+-     ({ register char __result;						      \
+-	__asm__ ("fucompp; fnstsw; testb $0x45, %%ah; setz %%al"	      \
+-		 : "=a" (__result) : "u" (y), "t" (x) : "cc", "st", "st(1)"); \
+-	__result; })
+-
+-#   define isgreaterequal(x, y) \
+-     ({ register char __result;						      \
+-	__asm__ ("fucompp; fnstsw; testb $0x05, %%ah; setz %%al"	      \
+-		 : "=a" (__result) : "u" (y), "t" (x) : "cc", "st", "st(1)"); \
+-	__result; })
+-
+-#   define isless(x, y) \
+-     ({ register char __result;						      \
+-	__asm__ ("fucompp; fnstsw; testb $0x45, %%ah; setz %%al"	      \
+-		 : "=a" (__result) : "u" (x), "t" (y) : "cc", "st", "st(1)"); \
+-	__result; })
+-
+-#   define islessequal(x, y) \
+-     ({ register char __result;						      \
+-	__asm__ ("fucompp; fnstsw; testb $0x05, %%ah; setz %%al"	      \
+-		 : "=a" (__result) : "u" (x), "t" (y) : "cc", "st", "st(1)"); \
+-	__result; })
+-
+-#   define islessgreater(x, y) \
+-     ({ register char __result;						      \
+-	__asm__ ("fucompp; fnstsw; testb $0x44, %%ah; setz %%al"	      \
+-		 : "=a" (__result) : "u" (y), "t" (x) : "cc", "st", "st(1)"); \
+-	__result; })
+-
+-#   define isunordered(x, y) \
+-     ({ register char __result;						      \
+-	__asm__ ("fucompp; fnstsw; sahf; setp %%al"			      \
+-		 : "=a" (__result) : "u" (y), "t" (x) : "cc", "st", "st(1)"); \
+-	__result; })
+-#  endif /* __i686__ */
+-# endif	/* GCC 2.97 */
+-
+-/* The gcc, version 2.7 or below, has problems with all this inlining
+-   code.  So disable it for this version of the compiler.  */
+-# if __GNUC_PREREQ (2, 8)
+-__BEGIN_NAMESPACE_C99
+-
+-/* Test for negative number.  Used in the signbit() macro.  */
+-__MATH_INLINE int
+-__NTH (__signbitf (float __x))
+-{
+-#  ifdef __SSE2_MATH__
+-  int __m;
+-  __asm ("pmovmskb %1, %0" : "=r" (__m) : "x" (__x));
+-  return (__m & 0x8) != 0;
+-#  else
+-  __extension__ union { float __f; int __i; } __u = { __f: __x };
+-  return __u.__i < 0;
+-#  endif
+-}
+-__MATH_INLINE int
+-__NTH (__signbit (double __x))
+-{
+-#  ifdef __SSE2_MATH__
+-  int __m;
+-  __asm ("pmovmskb %1, %0" : "=r" (__m) : "x" (__x));
+-  return (__m & 0x80) != 0;
+-#  else
+-  __extension__ union { double __d; int __i[2]; } __u = { __d: __x };
+-  return __u.__i[1] < 0;
+-#  endif
+-}
+-__MATH_INLINE int
+-__NTH (__signbitl (long double __x))
+-{
+-  __extension__ union { long double __l; int __i[3]; } __u = { __l: __x };
+-  return (__u.__i[2] & 0x8000) != 0;
+-}
+-
+-__END_NAMESPACE_C99
+-# endif
+-#endif
+-
+-
+-/* The gcc, version 2.7 or below, has problems with all this inlining
+-   code.  So disable it for this version of the compiler.  */
+-#if __GNUC_PREREQ (2, 8)
+-# if !__GNUC_PREREQ (3, 4) && !defined __NO_MATH_INLINES \
+-     && defined __OPTIMIZE__
+-/* GCC 3.4 introduced builtins for all functions below, so
+-   there's no need to define any of these inline functions.  */
+-
+-#  ifdef __USE_ISOC99
+-__BEGIN_NAMESPACE_C99
+-
+-/* Round to nearest integer.  */
+-#   ifdef __SSE_MATH__
+-__MATH_INLINE long int
+-__NTH (lrintf (float __x))
+-{
+-  long int __res;
+-  /* Mark as volatile since the result is dependent on the state of
+-     the SSE control register (the rounding mode).  Otherwise GCC might
+-     remove these assembler instructions since it does not know about
+-     the rounding mode change and cannot currently be told.  */
+-  __asm __volatile__ ("cvtss2si %1, %0" : "=r" (__res) : "xm" (__x));
+-  return __res;
+-}
+-#   endif
+-#   ifdef __SSE2_MATH__
+-__MATH_INLINE long int
+-__NTH (lrint (double __x))
+-{
+-  long int __res;
+-  /* Mark as volatile since the result is dependent on the state of
+-     the SSE control register (the rounding mode).  Otherwise GCC might
+-     remove these assembler instructions since it does not know about
+-     the rounding mode change and cannot currently be told.  */
+-  __asm __volatile__ ("cvtsd2si %1, %0" : "=r" (__res) : "xm" (__x));
+-  return __res;
+-}
+-#   endif
+-#   ifdef __x86_64__
+-__MATH_INLINE long long int
+-__NTH (llrintf (float __x))
+-{
+-  long long int __res;
+-  /* Mark as volatile since the result is dependent on the state of
+-     the SSE control register (the rounding mode).  Otherwise GCC might
+-     remove these assembler instructions since it does not know about
+-     the rounding mode change and cannot currently be told.  */
+-  __asm __volatile__ ("cvtss2si %1, %0" : "=r" (__res) : "xm" (__x));
+-  return __res;
+-}
+-__MATH_INLINE long long int
+-__NTH (llrint (double __x))
+-{
+-  long long int __res;
+-  /* Mark as volatile since the result is dependent on the state of
+-     the SSE control register (the rounding mode).  Otherwise GCC might
+-     remove these assembler instructions since it does not know about
+-     the rounding mode change and cannot currently be told.  */
+-  __asm __volatile__ ("cvtsd2si %1, %0" : "=r" (__res) : "xm" (__x));
+-  return __res;
+-}
+-#   endif
+-
+-#   if defined __FINITE_MATH_ONLY__ && __FINITE_MATH_ONLY__ > 0 \
+-       && defined __SSE2_MATH__
+-/* Determine maximum of two values.  */
+-__MATH_INLINE float
+-__NTH (fmaxf (float __x, float __y))
+-{
+-#    ifdef __AVX__
+-  float __res;
+-  __asm ("vmaxss %2, %1, %0" : "=x" (__res) : "x" (x), "xm" (__y));
+-  return __res;
+-#    else
+-  __asm ("maxss %1, %0" : "+x" (__x) : "xm" (__y));
+-  return __x;
+-#    endif
+-}
+-__MATH_INLINE double
+-__NTH (fmax (double __x, double __y))
+-{
+-#    ifdef __AVX__
+-  float __res;
+-  __asm ("vmaxsd %2, %1, %0" : "=x" (__res) : "x" (x), "xm" (__y));
+-  return __res;
+-#    else
+-  __asm ("maxsd %1, %0" : "+x" (__x) : "xm" (__y));
+-  return __x;
+-#    endif
+-}
+-
+-/* Determine minimum of two values.  */
+-__MATH_INLINE float
+-__NTH (fminf (float __x, float __y))
+-{
+-#    ifdef __AVX__
+-  float __res;
+-  __asm ("vminss %2, %1, %0" : "=x" (__res) : "x" (x), "xm" (__y));
+-  return __res;
+-#    else
+-  __asm ("minss %1, %0" : "+x" (__x) : "xm" (__y));
+-  return __x;
+-#    endif
+-}
+-__MATH_INLINE double
+-__NTH (fmin (double __x, double __y))
+-{
+-#    ifdef __AVX__
+-  float __res;
+-  __asm ("vminsd %2, %1, %0" : "=x" (__res) : "x" (x), "xm" (__y));
+-  return __res;
+-#    else
+-  __asm ("minsd %1, %0" : "+x" (__x) : "xm" (__y));
+-  return __x;
+-#    endif
+-}
+-#   endif
+-
+-__END_NAMESPACE_C99
+-#  endif
+-
+-#  if defined __SSE4_1__ && defined __SSE2_MATH__
+-#   if defined __USE_MISC || defined __USE_XOPEN_EXTENDED || defined __USE_ISOC99
+-__BEGIN_NAMESPACE_C99
+-
+-/* Round to nearest integer.  */
+-__MATH_INLINE double
+-__NTH (rint (double __x))
+-{
+-  double __res;
+-  /* Mark as volatile since the result is dependent on the state of
+-     the SSE control register (the rounding mode).  Otherwise GCC might
+-     remove these assembler instructions since it does not know about
+-     the rounding mode change and cannot currently be told.  */
+-  __asm __volatile__ ("roundsd $4, %1, %0" : "=x" (__res) : "xm" (__x));
+-  return __res;
+-}
+-__MATH_INLINE float
+-__NTH (rintf (float __x))
+-{
+-  float __res;
+-  /* Mark as volatile since the result is dependent on the state of
+-     the SSE control register (the rounding mode).  Otherwise GCC might
+-     remove these assembler instructions since it does not know about
+-     the rounding mode change and cannot currently be told.  */
+-  __asm __volatile__ ("roundss $4, %1, %0" : "=x" (__res) : "xm" (__x));
+-  return __res;
+-}
+-
+-#    ifdef __USE_ISOC99
+-/* Round to nearest integer without raising inexact exception.  */
+-__MATH_INLINE double
+-__NTH (nearbyint (double __x))
+-{
+-  double __res;
+-  /* Mark as volatile since the result is dependent on the state of
+-     the SSE control register (the rounding mode).  Otherwise GCC might
+-     remove these assembler instructions since it does not know about
+-     the rounding mode change and cannot currently be told.  */
+-  __asm __volatile__ ("roundsd $0xc, %1, %0" : "=x" (__res) : "xm" (__x));
+-  return __res;
+-}
+-__MATH_INLINE float
+-__NTH (nearbyintf (float __x))
+-{
+-  float __res;
+-  /* Mark as volatile since the result is dependent on the state of
+-     the SSE control register (the rounding mode).  Otherwise GCC might
+-     remove these assembler instructions since it does not know about
+-     the rounding mode change and cannot currently be told.  */
+-  __asm __volatile__ ("roundss $0xc, %1, %0" : "=x" (__res) : "xm" (__x));
+-  return __res;
+-}
+-#    endif
+-
+-__END_NAMESPACE_C99
+-#   endif
+-
+-__BEGIN_NAMESPACE_STD
+-/* Smallest integral value not less than X.  */
+-__MATH_INLINE double
+-__NTH (ceil (double __x))
+-{
+-  double __res;
+-  __asm ("roundsd $2, %1, %0" : "=x" (__res) : "xm" (__x));
+-  return __res;
+-}
+-__END_NAMESPACE_STD
+-
+-__BEGIN_NAMESPACE_C99
+-__MATH_INLINE float
+-__NTH (ceilf (float __x))
+-{
+-  float __res;
+-  __asm ("roundss $2, %1, %0" : "=x" (__res) : "xm" (__x));
+-  return __res;
+-}
+-__END_NAMESPACE_C99
+-
+-__BEGIN_NAMESPACE_STD
+-/* Largest integer not greater than X.  */
+-__MATH_INLINE double
+-__NTH (floor (double __x))
+-{
+-  double __res;
+-  __asm ("roundsd $1, %1, %0" : "=x" (__res) : "xm" (__x));
+-  return __res;
+-}
+-__END_NAMESPACE_STD
+-
+-__BEGIN_NAMESPACE_C99
+-__MATH_INLINE float
+-__NTH (floorf (float __x))
+-{
+-  float __res;
+-  __asm ("roundss $1, %1, %0" : "=x" (__res) : "xm" (__x));
+-  return __res;
+-}
+-__END_NAMESPACE_C99
+-#  endif
+-# endif
+-#endif
+-
+-#ifndef __x86_64__
+-# if ((!defined __NO_MATH_INLINES || defined __LIBC_INTERNAL_MATH_INLINES) \
+-     && defined __OPTIMIZE__)
+-
+-/* The inline functions do not set errno or raise necessarily the
+-   correct exceptions.  */
+-#  undef math_errhandling
+-
+-/* A macro to define float, double, and long double versions of various
+-   math functions for the ix87 FPU.  FUNC is the function name (which will
+-   be suffixed with f and l for the float and long double version,
+-   respectively).  OP is the name of the FPU operation.
+-   We define two sets of macros.  The set with the additional NP
+-   doesn't add a prototype declaration.  */
+-
+-#  if defined __USE_MISC || defined __USE_ISOC99
+-#   define __inline_mathop(func, op) \
+-  __inline_mathop_ (double, func, op)					      \
+-  __inline_mathop_ (float, __CONCAT(func,f), op)			      \
+-  __inline_mathop_ (long double, __CONCAT(func,l), op)
+-#   define __inline_mathopNP(func, op) \
+-  __inline_mathopNP_ (double, func, op)					      \
+-  __inline_mathopNP_ (float, __CONCAT(func,f), op)			      \
+-  __inline_mathopNP_ (long double, __CONCAT(func,l), op)
+-#  else
+-#   define __inline_mathop(func, op) \
+-  __inline_mathop_ (double, func, op)
+-#   define __inline_mathopNP(func, op) \
+-  __inline_mathopNP_ (double, func, op)
+-#  endif
+-
+-#  define __inline_mathop_(float_type, func, op) \
+-  __inline_mathop_decl_ (float_type, func, op, "0" (__x))
+-#  define __inline_mathopNP_(float_type, func, op) \
+-  __inline_mathop_declNP_ (float_type, func, op, "0" (__x))
+-
+-
+-#  if defined __USE_MISC || defined __USE_ISOC99
+-#   define __inline_mathop_decl(func, op, params...) \
+-  __inline_mathop_decl_ (double, func, op, params)			      \
+-  __inline_mathop_decl_ (float, __CONCAT(func,f), op, params)		      \
+-  __inline_mathop_decl_ (long double, __CONCAT(func,l), op, params)
+-#   define __inline_mathop_declNP(func, op, params...) \
+-  __inline_mathop_declNP_ (double, func, op, params)			      \
+-  __inline_mathop_declNP_ (float, __CONCAT(func,f), op, params)		      \
+-  __inline_mathop_declNP_ (long double, __CONCAT(func,l), op, params)
+-#  else
+-#   define __inline_mathop_decl(func, op, params...) \
+-  __inline_mathop_decl_ (double, func, op, params)
+-#   define __inline_mathop_declNP(func, op, params...) \
+-  __inline_mathop_declNP_ (double, func, op, params)
+-#  endif
+-
+-#  define __inline_mathop_decl_(float_type, func, op, params...) \
+-  __MATH_INLINE float_type func (float_type) __THROW;			      \
+-  __inline_mathop_declNP_ (float_type, func, op, params)
+-
+-#  define __inline_mathop_declNP_(float_type, func, op, params...) \
+-  __MATH_INLINE float_type __NTH (func (float_type __x))		      \
+-  {									      \
+-    register float_type __result;					      \
+-    __asm __volatile__ (op : "=t" (__result) : params);			      \
+-    return __result;							      \
+-  }
+-
+-
+-#if defined __USE_MISC || defined __USE_ISOC99
+-# define __inline_mathcode(func, arg, code) \
+-  __inline_mathcode_ (double, func, arg, code)				      \
+-  __inline_mathcode_ (float, __CONCAT(func,f), arg, code)		      \
+-  __inline_mathcode_ (long double, __CONCAT(func,l), arg, code)
+-# define __inline_mathcodeNP(func, arg, code) \
+-  __inline_mathcodeNP_ (double, func, arg, code)			      \
+-  __inline_mathcodeNP_ (float, __CONCAT(func,f), arg, code)		      \
+-  __inline_mathcodeNP_ (long double, __CONCAT(func,l), arg, code)
+-# define __inline_mathcode2(func, arg1, arg2, code) \
+-  __inline_mathcode2_ (double, func, arg1, arg2, code)			      \
+-  __inline_mathcode2_ (float, __CONCAT(func,f), arg1, arg2, code)	      \
+-  __inline_mathcode2_ (long double, __CONCAT(func,l), arg1, arg2, code)
+-# define __inline_mathcodeNP2(func, arg1, arg2, code) \
+-  __inline_mathcodeNP2_ (double, func, arg1, arg2, code)		      \
+-  __inline_mathcodeNP2_ (float, __CONCAT(func,f), arg1, arg2, code)	      \
+-  __inline_mathcodeNP2_ (long double, __CONCAT(func,l), arg1, arg2, code)
+-# define __inline_mathcode3(func, arg1, arg2, arg3, code) \
+-  __inline_mathcode3_ (double, func, arg1, arg2, arg3, code)		      \
+-  __inline_mathcode3_ (float, __CONCAT(func,f), arg1, arg2, arg3, code)	      \
+-  __inline_mathcode3_ (long double, __CONCAT(func,l), arg1, arg2, arg3, code)
+-# define __inline_mathcodeNP3(func, arg1, arg2, arg3, code) \
+-  __inline_mathcodeNP3_ (double, func, arg1, arg2, arg3, code)		      \
+-  __inline_mathcodeNP3_ (float, __CONCAT(func,f), arg1, arg2, arg3, code)     \
+-  __inline_mathcodeNP3_ (long double, __CONCAT(func,l), arg1, arg2, arg3, code)
+-#else
+-# define __inline_mathcode(func, arg, code) \
+-  __inline_mathcode_ (double, func, (arg), code)
+-# define __inline_mathcodeNP(func, arg, code) \
+-  __inline_mathcodeNP_ (double, func, (arg), code)
+-# define __inline_mathcode2(func, arg1, arg2, code) \
+-  __inline_mathcode2_ (double, func, arg1, arg2, code)
+-# define __inline_mathcodeNP2(func, arg1, arg2, code) \
+-  __inline_mathcodeNP2_ (double, func, arg1, arg2, code)
+-# define __inline_mathcode3(func, arg1, arg2, arg3, code) \
+-  __inline_mathcode3_ (double, func, arg1, arg2, arg3, code)
+-# define __inline_mathcodeNP3(func, arg1, arg2, arg3, code) \
+-  __inline_mathcodeNP3_ (double, func, arg1, arg2, arg3, code)
+-#endif
+-
+-#define __inline_mathcode_(float_type, func, arg, code) \
+-  __MATH_INLINE float_type func (float_type) __THROW;			      \
+-  __inline_mathcodeNP_(float_type, func, arg, code)
+-
+-#define __inline_mathcodeNP_(float_type, func, arg, code) \
+-  __MATH_INLINE float_type __NTH (func (float_type arg))		      \
+-  {									      \
+-    code;								      \
+-  }
+-
+-
+-#define __inline_mathcode2_(float_type, func, arg1, arg2, code) \
+-  __MATH_INLINE float_type func (float_type, float_type) __THROW;	      \
+-  __inline_mathcodeNP2_ (float_type, func, arg1, arg2, code)
+-
+-#define __inline_mathcodeNP2_(float_type, func, arg1, arg2, code) \
+-  __MATH_INLINE float_type __NTH (func (float_type arg1, float_type arg2))    \
+-  {									      \
+-    code;								      \
+-  }
+-
+-#define __inline_mathcode3_(float_type, func, arg1, arg2, arg3, code) \
+-  __MATH_INLINE float_type func (float_type, float_type, float_type) __THROW; \
+-  __inline_mathcodeNP3_(float_type, func, arg1, arg2, arg3, code)
+-
+-#define __inline_mathcodeNP3_(float_type, func, arg1, arg2, arg3, code) \
+-  __MATH_INLINE float_type __NTH (func (float_type arg1, float_type arg2,     \
+-					float_type arg3))		      \
+-  {									      \
+-    code;								      \
+-  }
+-#endif
+-
+-
+-#if !defined __NO_MATH_INLINES && defined __OPTIMIZE__
+-/* Miscellaneous functions */
+-
+-__inline_mathcode (__sgn, __x, \
+-  return __x == 0.0 ? 0.0 : (__x > 0.0 ? 1.0 : -1.0))
+-
+-/* __FAST_MATH__ is defined by gcc -ffast-math.  */
+-#ifdef __FAST_MATH__
+-__inline_mathcode (__pow2, __x, \
+-  register long double __value;						      \
+-  register long double __exponent;					      \
+-  __extension__ long long int __p = (long long int) __x;		      \
+-  if (__x == (long double) __p)						      \
+-    {									      \
+-      __asm __volatile__						      \
+-	("fscale"							      \
+-	 : "=t" (__value) : "0" (1.0), "u" (__x));			      \
+-      return __value;							      \
+-    }									      \
+-  __asm __volatile__							      \
+-    ("fld	%%st(0)\n\t"						      \
+-     "frndint			# int(x)\n\t"				      \
+-     "fxch\n\t"								      \
+-     "fsub	%%st(1)		# fract(x)\n\t"				      \
+-     "f2xm1			# 2^(fract(x)) - 1\n\t"			      \
+-     : "=t" (__value), "=u" (__exponent) : "0" (__x));			      \
+-  __value += 1.0;							      \
+-  __asm __volatile__							      \
+-    ("fscale"								      \
+-     : "=t" (__value) : "0" (__value), "u" (__exponent));		      \
+-  return __value)
+-
+-# ifdef __USE_GNU
+-#  define __sincos_code \
+-  register long double __cosr;						      \
+-  register long double __sinr;						      \
+-  __asm __volatile__							      \
+-    ("fsincos\n\t"							      \
+-     "fnstsw	%%ax\n\t"						      \
+-     "testl	$0x400, %%eax\n\t"					      \
+-     "jz	1f\n\t"							      \
+-     "fldpi\n\t"							      \
+-     "fadd	%%st(0)\n\t"						      \
+-     "fxch	%%st(1)\n\t"						      \
+-     "2: fprem1\n\t"							      \
+-     "fnstsw	%%ax\n\t"						      \
+-     "testl	$0x400, %%eax\n\t"					      \
+-     "jnz	2b\n\t"							      \
+-     "fstp	%%st(1)\n\t"						      \
+-     "fsincos\n\t"							      \
+-     "1:"								      \
+-     : "=t" (__cosr), "=u" (__sinr) : "0" (__x));			      \
+-  *__sinx = __sinr;							      \
+-  *__cosx = __cosr
+-
+-__MATH_INLINE void
+-__NTH (__sincos (double __x, double *__sinx, double *__cosx))
+-{
+-  __sincos_code;
+-}
+-
+-__MATH_INLINE void
+-__NTH (__sincosf (float __x, float *__sinx, float *__cosx))
+-{
+-  __sincos_code;
+-}
+-
+-__MATH_INLINE void
+-__NTH (__sincosl (long double __x, long double *__sinx, long double *__cosx))
+-{
+-  __sincos_code;
+-}
+-#   endif
+-
+-
+-/* Optimized inline implementation, sometimes with reduced precision
+-   and/or argument range.  */
+-
+-#   if __GNUC_PREREQ (3, 5)
+-#    define __expm1_code \
+-  register long double __temp;						      \
+-  __temp = __builtin_expm1l (__x);					      \
+-  return __temp ? __temp : __x
+-#   else
+-#    define __expm1_code \
+-  register long double __value;						      \
+-  register long double __exponent;					      \
+-  register long double __temp;						      \
+-  __asm __volatile__							      \
+-    ("fldl2e			# e^x - 1 = 2^(x * log2(e)) - 1\n\t"	      \
+-     "fmul	%%st(1)		# x * log2(e)\n\t"			      \
+-     "fst	%%st(1)\n\t"						      \
+-     "frndint			# int(x * log2(e))\n\t"			      \
+-     "fxch\n\t"								      \
+-     "fsub	%%st(1)		# fract(x * log2(e))\n\t"		      \
+-     "f2xm1			# 2^(fract(x * log2(e))) - 1\n\t"	      \
+-     "fscale			# 2^(x * log2(e)) - 2^(int(x * log2(e)))\n\t" \
+-     : "=t" (__value), "=u" (__exponent) : "0" (__x));			      \
+-  __asm __volatile__							      \
+-    ("fscale			# 2^int(x * log2(e))\n\t"		      \
+-     : "=t" (__temp) : "0" (1.0), "u" (__exponent));			      \
+-  __temp -= 1.0;							      \
+-  __temp += __value;							      \
+-  return __temp ? __temp : __x
+-#   endif
+-__inline_mathcodeNP_ (long double, __expm1l, __x, __expm1_code)
+-
+-#   if __GNUC_PREREQ (3, 4)
+-__inline_mathcodeNP_ (long double, __expl, __x, return __builtin_expl (__x))
+-#   else
+-#    define __exp_code \
+-  register long double __value;						      \
+-  register long double __exponent;					      \
+-  __asm __volatile__							      \
+-    ("fldl2e			# e^x = 2^(x * log2(e))\n\t"		      \
+-     "fmul	%%st(1)		# x * log2(e)\n\t"			      \
+-     "fst	%%st(1)\n\t"						      \
+-     "frndint			# int(x * log2(e))\n\t"			      \
+-     "fxch\n\t"								      \
+-     "fsub	%%st(1)		# fract(x * log2(e))\n\t"		      \
+-     "f2xm1			# 2^(fract(x * log2(e))) - 1\n\t"	      \
+-     : "=t" (__value), "=u" (__exponent) : "0" (__x));			      \
+-  __value += 1.0;							      \
+-  __asm __volatile__							      \
+-    ("fscale"								      \
+-     : "=t" (__value) : "0" (__value), "u" (__exponent));		      \
+-  return __value
+-__inline_mathcodeNP (exp, __x, __exp_code)
+-__inline_mathcodeNP_ (long double, __expl, __x, __exp_code)
+-#   endif
+-
+-
+-#   if !__GNUC_PREREQ (3, 5)
+-__inline_mathcodeNP (tan, __x, \
+-  register long double __value;						      \
+-  register long double __value2 __attribute__ ((__unused__));		      \
+-  __asm __volatile__							      \
+-    ("fptan"								      \
+-     : "=t" (__value2), "=u" (__value) : "0" (__x));			      \
+-  return __value)
+-#   endif
+-#  endif /* __FAST_MATH__ */
+-
+-
+-#  if __GNUC_PREREQ (3, 4)
+-__inline_mathcodeNP2_ (long double, __atan2l, __y, __x,
+-		       return __builtin_atan2l (__y, __x))
+-#  else
+-#   define __atan2_code \
+-  register long double __value;						      \
+-  __asm __volatile__							      \
+-    ("fpatan"								      \
+-     : "=t" (__value) : "0" (__x), "u" (__y) : "st(1)");		      \
+-  return __value
+-#   ifdef __FAST_MATH__
+-__inline_mathcodeNP2 (atan2, __y, __x, __atan2_code)
+-#   endif
+-__inline_mathcodeNP2_ (long double, __atan2l, __y, __x, __atan2_code)
+-#  endif
+-
+-
+-#  if defined __FAST_MATH__ && !__GNUC_PREREQ (3, 5)
+-__inline_mathcodeNP2 (fmod, __x, __y, \
+-  register long double __value;						      \
+-  __asm __volatile__							      \
+-    ("1:	fprem\n\t"						      \
+-     "fnstsw	%%ax\n\t"						      \
+-     "sahf\n\t"								      \
+-     "jp	1b"							      \
+-     : "=t" (__value) : "0" (__x), "u" (__y) : "ax", "cc");		      \
+-  return __value)
+-#  endif
+-
+-
+-#  ifdef __FAST_MATH__
+-#   if !__GNUC_PREREQ (3,3)
+-__inline_mathopNP (sqrt, "fsqrt")
+-__inline_mathopNP_ (long double, __sqrtl, "fsqrt")
+-#    define __libc_sqrtl(n) __sqrtl (n)
+-#   else
+-#    define __libc_sqrtl(n) __builtin_sqrtl (n)
+-#   endif
+-#  endif
+-
+-#  if __GNUC_PREREQ (2, 8)
+-__inline_mathcodeNP_ (double, fabs, __x, return __builtin_fabs (__x))
+-#   if defined __USE_MISC || defined __USE_ISOC99
+-__inline_mathcodeNP_ (float, fabsf, __x, return __builtin_fabsf (__x))
+-__inline_mathcodeNP_ (long double, fabsl, __x, return __builtin_fabsl (__x))
+-#   endif
+-__inline_mathcodeNP_ (long double, __fabsl, __x, return __builtin_fabsl (__x))
+-#  else
+-__inline_mathop (fabs, "fabs")
+-__inline_mathop_ (long double, __fabsl, "fabs")
+-# endif
+-
+-#  ifdef __FAST_MATH__
+-#   if !__GNUC_PREREQ (3, 4)
+-/* The argument range of this inline version is reduced.  */
+-__inline_mathopNP (sin, "fsin")
+-/* The argument range of this inline version is reduced.  */
+-__inline_mathopNP (cos, "fcos")
+-
+-__inline_mathop_declNP (log, "fldln2; fxch; fyl2x", "0" (__x) : "st(1)")
+-#   endif
+-
+-#   if !__GNUC_PREREQ (3, 5)
+-__inline_mathop_declNP (log10, "fldlg2; fxch; fyl2x", "0" (__x) : "st(1)")
+-
+-__inline_mathcodeNP (asin, __x, return __atan2l (__x, __libc_sqrtl (1.0 - __x * __x)))
+-__inline_mathcodeNP (acos, __x, return __atan2l (__libc_sqrtl (1.0 - __x * __x), __x))
+-#   endif
+-
+-#   if !__GNUC_PREREQ (3, 4)
+-__inline_mathop_declNP (atan, "fld1; fpatan", "0" (__x) : "st(1)")
+-#   endif
+-#  endif /* __FAST_MATH__ */
+-
+-__inline_mathcode_ (long double, __sgn1l, __x, \
+-  __extension__ union { long double __xld; unsigned int __xi[3]; } __n =      \
+-    { __xld: __x };							      \
+-  __n.__xi[2] = (__n.__xi[2] & 0x8000) | 0x3fff;			      \
+-  __n.__xi[1] = 0x80000000;						      \
+-  __n.__xi[0] = 0;							      \
+-  return __n.__xld)
+-
+-
+-#  ifdef __FAST_MATH__
+-/* The argument range of the inline version of sinhl is slightly reduced.  */
+-__inline_mathcodeNP (sinh, __x, \
+-  register long double __exm1 = __expm1l (__fabsl (__x));		      \
+-  return 0.5 * (__exm1 / (__exm1 + 1.0) + __exm1) * __sgn1l (__x))
+-
+-__inline_mathcodeNP (cosh, __x, \
+-  register long double __ex = __expl (__x);				      \
+-  return 0.5 * (__ex + 1.0 / __ex))
+-
+-__inline_mathcodeNP (tanh, __x, \
+-  register long double __exm1 = __expm1l (-__fabsl (__x + __x));	      \
+-  return __exm1 / (__exm1 + 2.0) * __sgn1l (-__x))
+-#  endif
+-
+-__inline_mathcodeNP (floor, __x, \
+-  register long double __value;						      \
+-  register int __ignore;						      \
+-  unsigned short int __cw;						      \
+-  unsigned short int __cwtmp;						      \
+-  __asm __volatile ("fnstcw %3\n\t"					      \
+-		    "movzwl %3, %1\n\t"					      \
+-		    "andl $0xf3ff, %1\n\t"				      \
+-		    "orl $0x0400, %1\n\t"	/* rounding down */	      \
+-		    "movw %w1, %2\n\t"					      \
+-		    "fldcw %2\n\t"					      \
+-		    "frndint\n\t"					      \
+-		    "fldcw %3"						      \
+-		    : "=t" (__value), "=&q" (__ignore), "=m" (__cwtmp),	      \
+-		      "=m" (__cw)					      \
+-		    : "0" (__x));					      \
+-  return __value)
+-
+-__inline_mathcodeNP (ceil, __x, \
+-  register long double __value;						      \
+-  register int __ignore;						      \
+-  unsigned short int __cw;						      \
+-  unsigned short int __cwtmp;						      \
+-  __asm __volatile ("fnstcw %3\n\t"					      \
+-		    "movzwl %3, %1\n\t"					      \
+-		    "andl $0xf3ff, %1\n\t"				      \
+-		    "orl $0x0800, %1\n\t"	/* rounding up */	      \
+-		    "movw %w1, %2\n\t"					      \
+-		    "fldcw %2\n\t"					      \
+-		    "frndint\n\t"					      \
+-		    "fldcw %3"						      \
+-		    : "=t" (__value), "=&q" (__ignore), "=m" (__cwtmp),	      \
+-		      "=m" (__cw)					      \
+-		    : "0" (__x));					      \
+-  return __value)
+-
+-#  ifdef __FAST_MATH__
+-#   define __ldexp_code \
+-  register long double __value;						      \
+-  __asm __volatile__							      \
+-    ("fscale"								      \
+-     : "=t" (__value) : "0" (__x), "u" ((long double) __y));		      \
+-  return __value
+-
+-__MATH_INLINE double
+-__NTH (ldexp (double __x, int __y))
+-{
+-  __ldexp_code;
+-}
+-#  endif
+-
+-
+-/* Optimized versions for some non-standardized functions.  */
+-#  if defined __USE_ISOC99 || defined __USE_MISC
+-
+-#   ifdef __FAST_MATH__
+-__inline_mathcodeNP (expm1, __x, __expm1_code)
+-
+-/* We cannot rely on M_SQRT being defined.  So we do it for ourself
+-   here.  */
+-#    define __M_SQRT2	1.41421356237309504880L	/* sqrt(2) */
+-
+-#    if !__GNUC_PREREQ (3, 5)
+-__inline_mathcodeNP (log1p, __x, \
+-  register long double __value;						      \
+-  if (__fabsl (__x) >= 1.0 - 0.5 * __M_SQRT2)				      \
+-    __value = logl (1.0 + __x);						      \
+-  else									      \
+-    __asm __volatile__							      \
+-      ("fldln2\n\t"							      \
+-       "fxch\n\t"							      \
+-       "fyl2xp1"							      \
+-       : "=t" (__value) : "0" (__x) : "st(1)");				      \
+-  return __value)
+-#    endif
+-
+-
+-/* The argument range of the inline version of asinhl is slightly reduced.  */
+-__inline_mathcodeNP (asinh, __x, \
+-  register long double  __y = __fabsl (__x);				      \
+-  return (log1pl (__y * __y / (__libc_sqrtl (__y * __y + 1.0) + 1.0) + __y)   \
+-	  * __sgn1l (__x)))
+-
+-__inline_mathcodeNP (acosh, __x, \
+-  return logl (__x + __libc_sqrtl (__x - 1.0) * __libc_sqrtl (__x + 1.0)))
+-
+-__inline_mathcodeNP (atanh, __x, \
+-  register long double __y = __fabsl (__x);				      \
+-  return -0.5 * log1pl (-(__y + __y) / (1.0 + __y)) * __sgn1l (__x))
+-
+-/* The argument range of the inline version of hypotl is slightly reduced.  */
+-__inline_mathcodeNP2 (hypot, __x, __y,
+-		      return __libc_sqrtl (__x * __x + __y * __y))
+-
+-#    if !__GNUC_PREREQ (3, 5)
+-__inline_mathcodeNP(logb, __x, \
+-  register long double __value;						      \
+-  register long double __junk;						      \
+-  __asm __volatile__							      \
+-    ("fxtract\n\t"							      \
+-     : "=t" (__junk), "=u" (__value) : "0" (__x));			      \
+-  return __value)
+-#    endif
+-
+-#   endif
+-#  endif
+-
+-#  ifdef __USE_ISOC99
+-#   ifdef __FAST_MATH__
+-
+-#    if !__GNUC_PREREQ (3, 5)
+-__inline_mathop_declNP (log2, "fld1; fxch; fyl2x", "0" (__x) : "st(1)")
+-#    endif
+-
+-__MATH_INLINE float
+-__NTH (ldexpf (float __x, int __y))
+-{
+-  __ldexp_code;
+-}
+-
+-__MATH_INLINE long double
+-__NTH (ldexpl (long double __x, int __y))
+-{
+-  __ldexp_code;
+-}
+-
+-__inline_mathopNP (rint, "frndint")
+-#   endif /* __FAST_MATH__ */
+-
+-#   define __lrint_code \
+-  long int __lrintres;							      \
+-  __asm__ __volatile__							      \
+-    ("fistpl %0"							      \
+-     : "=m" (__lrintres) : "t" (__x) : "st");				      \
+-  return __lrintres
+-__MATH_INLINE long int
+-__NTH (lrintf (float __x))
+-{
+-  __lrint_code;
+-}
+-__MATH_INLINE long int
+-__NTH (lrint (double __x))
+-{
+-  __lrint_code;
+-}
+-__MATH_INLINE long int
+-__NTH (lrintl (long double __x))
+-{
+-  __lrint_code;
+-}
+-#   undef __lrint_code
+-
+-#   define __llrint_code \
+-  long long int __llrintres;						      \
+-  __asm__ __volatile__							      \
+-    ("fistpll %0"							      \
+-     : "=m" (__llrintres) : "t" (__x) : "st");				      \
+-  return __llrintres
+-__MATH_INLINE long long int
+-__NTH (llrintf (float __x))
+-{
+-  __llrint_code;
+-}
+-__MATH_INLINE long long int
+-__NTH (llrint (double __x))
+-{
+-  __llrint_code;
+-}
+-__MATH_INLINE long long int
+-__NTH (llrintl (long double __x))
+-{
+-  __llrint_code;
+-}
+-#   undef __llrint_code
+-
+-# endif
+-
+-
+-#  ifdef __USE_MISC
+-
+-#   if defined __FAST_MATH__ && !__GNUC_PREREQ (3, 5)
+-__inline_mathcodeNP2 (drem, __x, __y, \
+-  register double __value;						      \
+-  register int __clobbered;						      \
+-  __asm __volatile__							      \
+-    ("1:	fprem1\n\t"						      \
+-     "fstsw	%%ax\n\t"						      \
+-     "sahf\n\t"								      \
+-     "jp	1b"							      \
+-     : "=t" (__value), "=&a" (__clobbered) : "0" (__x), "u" (__y) : "cc");    \
+-  return __value)
+-#  endif
+-
+-
+-/* This function is used in the `isfinite' macro.  */
+-__MATH_INLINE int
+-__NTH (__finite (double __x))
+-{
+-  return (__extension__
+-	  (((((union { double __d; int __i[2]; }) {__d: __x}).__i[1]
+-	     | 0x800fffffu) + 1) >> 31));
+-}
+-
+-/* Miscellaneous functions */
+-# ifdef __FAST_MATH__
+-__inline_mathcode (__coshm1, __x, \
+-  register long double __exm1 = __expm1l (__fabsl (__x));		      \
+-  return 0.5 * (__exm1 / (__exm1 + 1.0)) * __exm1)
+-
+-__inline_mathcode (__acosh1p, __x, \
+-  return log1pl (__x + __libc_sqrtl (__x) * __libc_sqrtl (__x + 2.0)))
+-
+-# endif /* __FAST_MATH__ */
+-#endif /* __USE_MISC  */
+-
+-/* Undefine some of the large macros which are not used anymore.  */
+-#undef __atan2_code
+-#ifdef __FAST_MATH__
+-# undef __expm1_code
+-# undef __exp_code
+-# undef __sincos_code
+-#endif /* __FAST_MATH__ */
+-
+-#endif /* __NO_MATH_INLINES  */
+-
+-
+-/* This code is used internally in the GNU libc.  */
+-#ifdef __LIBC_INTERNAL_MATH_INLINES
+-__inline_mathop (__ieee754_sqrt, "fsqrt")
+-__inline_mathcode2 (__ieee754_atan2, __y, __x,
+-		    register long double __value;
+-		    __asm __volatile__ ("fpatan\n\t"
+-					: "=t" (__value)
+-					: "0" (__x), "u" (__y) : "st(1)");
+-		    return __value;)
+-# endif
+-
+-#endif /* !__x86_64__ */
+diff -urN a/sysdeps/x86/fpu/bits/mathinline.h b/sysdeps/x86/fpu/bits/mathinline.h
+--- a/sysdeps/x86/fpu/bits/mathinline.h	1970-01-01 00:00:00.000000000 +0000
++++ b/sysdeps/x86/fpu/bits/mathinline.h	2014-01-31 12:31:50.197839921 +0000
+@@ -0,0 +1,968 @@
++/* Inline math functions for i387 and SSE.
++   Copyright (C) 1995-2012 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <http://www.gnu.org/licenses/>.  */
++
++#ifndef _MATH_H
++# error "Never use <bits/mathinline.h> directly; include <math.h> instead."
++#endif
++
++#ifndef __extern_always_inline
++# define __MATH_INLINE __inline
++#else
++# define __MATH_INLINE __extern_always_inline
++#endif
++
++
++#if defined __USE_ISOC99 && defined __GNUC__ && __GNUC__ >= 2
++/* GCC 2.97 and up have builtins that actually can be used.  */
++# if !__GNUC_PREREQ (2,97)
++/* ISO C99 defines some macros to perform unordered comparisons.  The
++   ix87 FPU supports this with special opcodes and we should use them.
++   These must not be inline functions since we have to be able to handle
++   all floating-point types.  */
++#  undef isgreater
++#  undef isgreaterequal
++#  undef isless
++#  undef islessequal
++#  undef islessgreater
++#  undef isunordered
++#  ifdef __i686__
++/* For the PentiumPro and more recent processors we can provide
++   better code.  */
++#   define isgreater(x, y) \
++     ({ register char __result;						      \
++	__asm__ ("fucomip %%st(1), %%st; seta %%al"			      \
++		 : "=a" (__result) : "u" (y), "t" (x) : "cc", "st");	      \
++	__result; })
++#   define isgreaterequal(x, y) \
++     ({ register char __result;						      \
++	__asm__ ("fucomip %%st(1), %%st; setae %%al"			      \
++		 : "=a" (__result) : "u" (y), "t" (x) : "cc", "st");	      \
++	__result; })
++
++#   define isless(x, y) \
++     ({ register char __result;						      \
++	__asm__ ("fucomip %%st(1), %%st; seta %%al"			      \
++		 : "=a" (__result) : "u" (x), "t" (y) : "cc", "st");	      \
++	__result; })
++
++#   define islessequal(x, y) \
++     ({ register char __result;						      \
++	__asm__ ("fucomip %%st(1), %%st; setae %%al"			      \
++		 : "=a" (__result) : "u" (x), "t" (y) : "cc", "st");	      \
++	__result; })
++
++#   define islessgreater(x, y) \
++     ({ register char __result;						      \
++	__asm__ ("fucomip %%st(1), %%st; setne %%al"			      \
++		 : "=a" (__result) : "u" (y), "t" (x) : "cc", "st");	      \
++	__result; })
++
++#   define isunordered(x, y) \
++     ({ register char __result;						      \
++	__asm__ ("fucomip %%st(1), %%st; setp %%al"			      \
++		 : "=a" (__result) : "u" (y), "t" (x) : "cc", "st");	      \
++	__result; })
++#  else
++/* This is the dumb, portable code for i386 and above.  */
++#   define isgreater(x, y) \
++     ({ register char __result;						      \
++	__asm__ ("fucompp; fnstsw; testb $0x45, %%ah; setz %%al"	      \
++		 : "=a" (__result) : "u" (y), "t" (x) : "cc", "st", "st(1)"); \
++	__result; })
++
++#   define isgreaterequal(x, y) \
++     ({ register char __result;						      \
++	__asm__ ("fucompp; fnstsw; testb $0x05, %%ah; setz %%al"	      \
++		 : "=a" (__result) : "u" (y), "t" (x) : "cc", "st", "st(1)"); \
++	__result; })
++
++#   define isless(x, y) \
++     ({ register char __result;						      \
++	__asm__ ("fucompp; fnstsw; testb $0x45, %%ah; setz %%al"	      \
++		 : "=a" (__result) : "u" (x), "t" (y) : "cc", "st", "st(1)"); \
++	__result; })
++
++#   define islessequal(x, y) \
++     ({ register char __result;						      \
++	__asm__ ("fucompp; fnstsw; testb $0x05, %%ah; setz %%al"	      \
++		 : "=a" (__result) : "u" (x), "t" (y) : "cc", "st", "st(1)"); \
++	__result; })
++
++#   define islessgreater(x, y) \
++     ({ register char __result;						      \
++	__asm__ ("fucompp; fnstsw; testb $0x44, %%ah; setz %%al"	      \
++		 : "=a" (__result) : "u" (y), "t" (x) : "cc", "st", "st(1)"); \
++	__result; })
++
++#   define isunordered(x, y) \
++     ({ register char __result;						      \
++	__asm__ ("fucompp; fnstsw; sahf; setp %%al"			      \
++		 : "=a" (__result) : "u" (y), "t" (x) : "cc", "st", "st(1)"); \
++	__result; })
++#  endif /* __i686__ */
++# endif	/* GCC 2.97 */
++
++/* The gcc, version 2.7 or below, has problems with all this inlining
++   code.  So disable it for this version of the compiler.  */
++# if __GNUC_PREREQ (2, 8)
++__BEGIN_NAMESPACE_C99
++
++/* Test for negative number.  Used in the signbit() macro.  */
++__MATH_INLINE int
++__NTH (__signbitf (float __x))
++{
++#  ifdef __SSE2_MATH__
++  int __m;
++  __asm ("pmovmskb %1, %0" : "=r" (__m) : "x" (__x));
++  return (__m & 0x8) != 0;
++#  else
++  __extension__ union { float __f; int __i; } __u = { __f: __x };
++  return __u.__i < 0;
++#  endif
++}
++__MATH_INLINE int
++__NTH (__signbit (double __x))
++{
++#  ifdef __SSE2_MATH__
++  int __m;
++  __asm ("pmovmskb %1, %0" : "=r" (__m) : "x" (__x));
++  return (__m & 0x80) != 0;
++#  else
++  __extension__ union { double __d; int __i[2]; } __u = { __d: __x };
++  return __u.__i[1] < 0;
++#  endif
++}
++__MATH_INLINE int
++__NTH (__signbitl (long double __x))
++{
++  __extension__ union { long double __l; int __i[3]; } __u = { __l: __x };
++  return (__u.__i[2] & 0x8000) != 0;
++}
++
++__END_NAMESPACE_C99
++# endif
++#endif
++
++
++/* The gcc, version 2.7 or below, has problems with all this inlining
++   code.  So disable it for this version of the compiler.  */
++#if __GNUC_PREREQ (2, 8)
++# if !__GNUC_PREREQ (3, 4) && !defined __NO_MATH_INLINES \
++     && defined __OPTIMIZE__
++/* GCC 3.4 introduced builtins for all functions below, so
++   there's no need to define any of these inline functions.  */
++
++#  ifdef __USE_ISOC99
++__BEGIN_NAMESPACE_C99
++
++/* Round to nearest integer.  */
++#   ifdef __SSE_MATH__
++__MATH_INLINE long int
++__NTH (lrintf (float __x))
++{
++  long int __res;
++  /* Mark as volatile since the result is dependent on the state of
++     the SSE control register (the rounding mode).  Otherwise GCC might
++     remove these assembler instructions since it does not know about
++     the rounding mode change and cannot currently be told.  */
++  __asm __volatile__ ("cvtss2si %1, %0" : "=r" (__res) : "xm" (__x));
++  return __res;
++}
++#   endif
++#   ifdef __SSE2_MATH__
++__MATH_INLINE long int
++__NTH (lrint (double __x))
++{
++  long int __res;
++  /* Mark as volatile since the result is dependent on the state of
++     the SSE control register (the rounding mode).  Otherwise GCC might
++     remove these assembler instructions since it does not know about
++     the rounding mode change and cannot currently be told.  */
++  __asm __volatile__ ("cvtsd2si %1, %0" : "=r" (__res) : "xm" (__x));
++  return __res;
++}
++#   endif
++#   ifdef __x86_64__
++__MATH_INLINE long long int
++__NTH (llrintf (float __x))
++{
++  long long int __res;
++  /* Mark as volatile since the result is dependent on the state of
++     the SSE control register (the rounding mode).  Otherwise GCC might
++     remove these assembler instructions since it does not know about
++     the rounding mode change and cannot currently be told.  */
++  __asm __volatile__ ("cvtss2si %1, %0" : "=r" (__res) : "xm" (__x));
++  return __res;
++}
++__MATH_INLINE long long int
++__NTH (llrint (double __x))
++{
++  long long int __res;
++  /* Mark as volatile since the result is dependent on the state of
++     the SSE control register (the rounding mode).  Otherwise GCC might
++     remove these assembler instructions since it does not know about
++     the rounding mode change and cannot currently be told.  */
++  __asm __volatile__ ("cvtsd2si %1, %0" : "=r" (__res) : "xm" (__x));
++  return __res;
++}
++#   endif
++
++#   if defined __FINITE_MATH_ONLY__ && __FINITE_MATH_ONLY__ > 0 \
++       && defined __SSE2_MATH__
++/* Determine maximum of two values.  */
++__MATH_INLINE float
++__NTH (fmaxf (float __x, float __y))
++{
++#    ifdef __AVX__
++  float __res;
++  __asm ("vmaxss %2, %1, %0" : "=x" (__res) : "x" (x), "xm" (__y));
++  return __res;
++#    else
++  __asm ("maxss %1, %0" : "+x" (__x) : "xm" (__y));
++  return __x;
++#    endif
++}
++__MATH_INLINE double
++__NTH (fmax (double __x, double __y))
++{
++#    ifdef __AVX__
++  float __res;
++  __asm ("vmaxsd %2, %1, %0" : "=x" (__res) : "x" (x), "xm" (__y));
++  return __res;
++#    else
++  __asm ("maxsd %1, %0" : "+x" (__x) : "xm" (__y));
++  return __x;
++#    endif
++}
++
++/* Determine minimum of two values.  */
++__MATH_INLINE float
++__NTH (fminf (float __x, float __y))
++{
++#    ifdef __AVX__
++  float __res;
++  __asm ("vminss %2, %1, %0" : "=x" (__res) : "x" (x), "xm" (__y));
++  return __res;
++#    else
++  __asm ("minss %1, %0" : "+x" (__x) : "xm" (__y));
++  return __x;
++#    endif
++}
++__MATH_INLINE double
++__NTH (fmin (double __x, double __y))
++{
++#    ifdef __AVX__
++  float __res;
++  __asm ("vminsd %2, %1, %0" : "=x" (__res) : "x" (x), "xm" (__y));
++  return __res;
++#    else
++  __asm ("minsd %1, %0" : "+x" (__x) : "xm" (__y));
++  return __x;
++#    endif
++}
++#   endif
++
++__END_NAMESPACE_C99
++#  endif
++
++#  if defined __SSE4_1__ && defined __SSE2_MATH__
++#   if defined __USE_MISC || defined __USE_XOPEN_EXTENDED || defined __USE_ISOC99
++__BEGIN_NAMESPACE_C99
++
++/* Round to nearest integer.  */
++__MATH_INLINE double
++__NTH (rint (double __x))
++{
++  double __res;
++  /* Mark as volatile since the result is dependent on the state of
++     the SSE control register (the rounding mode).  Otherwise GCC might
++     remove these assembler instructions since it does not know about
++     the rounding mode change and cannot currently be told.  */
++  __asm __volatile__ ("roundsd $4, %1, %0" : "=x" (__res) : "xm" (__x));
++  return __res;
++}
++__MATH_INLINE float
++__NTH (rintf (float __x))
++{
++  float __res;
++  /* Mark as volatile since the result is dependent on the state of
++     the SSE control register (the rounding mode).  Otherwise GCC might
++     remove these assembler instructions since it does not know about
++     the rounding mode change and cannot currently be told.  */
++  __asm __volatile__ ("roundss $4, %1, %0" : "=x" (__res) : "xm" (__x));
++  return __res;
++}
++
++#    ifdef __USE_ISOC99
++/* Round to nearest integer without raising inexact exception.  */
++__MATH_INLINE double
++__NTH (nearbyint (double __x))
++{
++  double __res;
++  /* Mark as volatile since the result is dependent on the state of
++     the SSE control register (the rounding mode).  Otherwise GCC might
++     remove these assembler instructions since it does not know about
++     the rounding mode change and cannot currently be told.  */
++  __asm __volatile__ ("roundsd $0xc, %1, %0" : "=x" (__res) : "xm" (__x));
++  return __res;
++}
++__MATH_INLINE float
++__NTH (nearbyintf (float __x))
++{
++  float __res;
++  /* Mark as volatile since the result is dependent on the state of
++     the SSE control register (the rounding mode).  Otherwise GCC might
++     remove these assembler instructions since it does not know about
++     the rounding mode change and cannot currently be told.  */
++  __asm __volatile__ ("roundss $0xc, %1, %0" : "=x" (__res) : "xm" (__x));
++  return __res;
++}
++#    endif
++
++__END_NAMESPACE_C99
++#   endif
++
++__BEGIN_NAMESPACE_STD
++/* Smallest integral value not less than X.  */
++__MATH_INLINE double
++__NTH (ceil (double __x))
++{
++  double __res;
++  __asm ("roundsd $2, %1, %0" : "=x" (__res) : "xm" (__x));
++  return __res;
++}
++__END_NAMESPACE_STD
++
++__BEGIN_NAMESPACE_C99
++__MATH_INLINE float
++__NTH (ceilf (float __x))
++{
++  float __res;
++  __asm ("roundss $2, %1, %0" : "=x" (__res) : "xm" (__x));
++  return __res;
++}
++__END_NAMESPACE_C99
++
++__BEGIN_NAMESPACE_STD
++/* Largest integer not greater than X.  */
++__MATH_INLINE double
++__NTH (floor (double __x))
++{
++  double __res;
++  __asm ("roundsd $1, %1, %0" : "=x" (__res) : "xm" (__x));
++  return __res;
++}
++__END_NAMESPACE_STD
++
++__BEGIN_NAMESPACE_C99
++__MATH_INLINE float
++__NTH (floorf (float __x))
++{
++  float __res;
++  __asm ("roundss $1, %1, %0" : "=x" (__res) : "xm" (__x));
++  return __res;
++}
++__END_NAMESPACE_C99
++#  endif
++# endif
++#endif
++
++#ifndef __x86_64__
++# if ((!defined __NO_MATH_INLINES || defined __LIBC_INTERNAL_MATH_INLINES) \
++     && defined __OPTIMIZE__)
++
++/* The inline functions do not set errno or raise necessarily the
++   correct exceptions.  */
++#  undef math_errhandling
++
++/* A macro to define float, double, and long double versions of various
++   math functions for the ix87 FPU.  FUNC is the function name (which will
++   be suffixed with f and l for the float and long double version,
++   respectively).  OP is the name of the FPU operation.
++   We define two sets of macros.  The set with the additional NP
++   doesn't add a prototype declaration.  */
++
++#  if defined __USE_MISC || defined __USE_ISOC99
++#   define __inline_mathop(func, op) \
++  __inline_mathop_ (double, func, op)					      \
++  __inline_mathop_ (float, __CONCAT(func,f), op)			      \
++  __inline_mathop_ (long double, __CONCAT(func,l), op)
++#   define __inline_mathopNP(func, op) \
++  __inline_mathopNP_ (double, func, op)					      \
++  __inline_mathopNP_ (float, __CONCAT(func,f), op)			      \
++  __inline_mathopNP_ (long double, __CONCAT(func,l), op)
++#  else
++#   define __inline_mathop(func, op) \
++  __inline_mathop_ (double, func, op)
++#   define __inline_mathopNP(func, op) \
++  __inline_mathopNP_ (double, func, op)
++#  endif
++
++#  define __inline_mathop_(float_type, func, op) \
++  __inline_mathop_decl_ (float_type, func, op, "0" (__x))
++#  define __inline_mathopNP_(float_type, func, op) \
++  __inline_mathop_declNP_ (float_type, func, op, "0" (__x))
++
++
++#  if defined __USE_MISC || defined __USE_ISOC99
++#   define __inline_mathop_decl(func, op, params...) \
++  __inline_mathop_decl_ (double, func, op, params)			      \
++  __inline_mathop_decl_ (float, __CONCAT(func,f), op, params)		      \
++  __inline_mathop_decl_ (long double, __CONCAT(func,l), op, params)
++#   define __inline_mathop_declNP(func, op, params...) \
++  __inline_mathop_declNP_ (double, func, op, params)			      \
++  __inline_mathop_declNP_ (float, __CONCAT(func,f), op, params)		      \
++  __inline_mathop_declNP_ (long double, __CONCAT(func,l), op, params)
++#  else
++#   define __inline_mathop_decl(func, op, params...) \
++  __inline_mathop_decl_ (double, func, op, params)
++#   define __inline_mathop_declNP(func, op, params...) \
++  __inline_mathop_declNP_ (double, func, op, params)
++#  endif
++
++#  define __inline_mathop_decl_(float_type, func, op, params...) \
++  __MATH_INLINE float_type func (float_type) __THROW;			      \
++  __inline_mathop_declNP_ (float_type, func, op, params)
++
++#  define __inline_mathop_declNP_(float_type, func, op, params...) \
++  __MATH_INLINE float_type __NTH (func (float_type __x))		      \
++  {									      \
++    register float_type __result;					      \
++    __asm __volatile__ (op : "=t" (__result) : params);			      \
++    return __result;							      \
++  }
++
++
++#  if defined __USE_MISC || defined __USE_ISOC99
++#   define __inline_mathcode(func, arg, code) \
++  __inline_mathcode_ (double, func, arg, code)				      \
++  __inline_mathcode_ (float, __CONCAT(func,f), arg, code)		      \
++  __inline_mathcode_ (long double, __CONCAT(func,l), arg, code)
++#   define __inline_mathcodeNP(func, arg, code) \
++  __inline_mathcodeNP_ (double, func, arg, code)			      \
++  __inline_mathcodeNP_ (float, __CONCAT(func,f), arg, code)		      \
++  __inline_mathcodeNP_ (long double, __CONCAT(func,l), arg, code)
++#   define __inline_mathcode2(func, arg1, arg2, code) \
++  __inline_mathcode2_ (double, func, arg1, arg2, code)			      \
++  __inline_mathcode2_ (float, __CONCAT(func,f), arg1, arg2, code)	      \
++  __inline_mathcode2_ (long double, __CONCAT(func,l), arg1, arg2, code)
++#   define __inline_mathcodeNP2(func, arg1, arg2, code) \
++  __inline_mathcodeNP2_ (double, func, arg1, arg2, code)		      \
++  __inline_mathcodeNP2_ (float, __CONCAT(func,f), arg1, arg2, code)	      \
++  __inline_mathcodeNP2_ (long double, __CONCAT(func,l), arg1, arg2, code)
++#   define __inline_mathcode3(func, arg1, arg2, arg3, code) \
++  __inline_mathcode3_ (double, func, arg1, arg2, arg3, code)		      \
++  __inline_mathcode3_ (float, __CONCAT(func,f), arg1, arg2, arg3, code)	      \
++  __inline_mathcode3_ (long double, __CONCAT(func,l), arg1, arg2, arg3, code)
++#   define __inline_mathcodeNP3(func, arg1, arg2, arg3, code) \
++  __inline_mathcodeNP3_ (double, func, arg1, arg2, arg3, code)		      \
++  __inline_mathcodeNP3_ (float, __CONCAT(func,f), arg1, arg2, arg3, code)     \
++  __inline_mathcodeNP3_ (long double, __CONCAT(func,l), arg1, arg2, arg3, code)
++#  else
++#   define __inline_mathcode(func, arg, code) \
++  __inline_mathcode_ (double, func, (arg), code)
++#   define __inline_mathcodeNP(func, arg, code) \
++  __inline_mathcodeNP_ (double, func, (arg), code)
++#   define __inline_mathcode2(func, arg1, arg2, code) \
++  __inline_mathcode2_ (double, func, arg1, arg2, code)
++#   define __inline_mathcodeNP2(func, arg1, arg2, code) \
++  __inline_mathcodeNP2_ (double, func, arg1, arg2, code)
++#   define __inline_mathcode3(func, arg1, arg2, arg3, code) \
++  __inline_mathcode3_ (double, func, arg1, arg2, arg3, code)
++#   define __inline_mathcodeNP3(func, arg1, arg2, arg3, code) \
++  __inline_mathcodeNP3_ (double, func, arg1, arg2, arg3, code)
++#  endif
++
++#  define __inline_mathcode_(float_type, func, arg, code) \
++  __MATH_INLINE float_type func (float_type) __THROW;			      \
++  __inline_mathcodeNP_(float_type, func, arg, code)
++
++#  define __inline_mathcodeNP_(float_type, func, arg, code) \
++  __MATH_INLINE float_type __NTH (func (float_type arg))		      \
++  {									      \
++    code;								      \
++  }
++
++
++#  define __inline_mathcode2_(float_type, func, arg1, arg2, code) \
++  __MATH_INLINE float_type func (float_type, float_type) __THROW;	      \
++  __inline_mathcodeNP2_ (float_type, func, arg1, arg2, code)
++
++#  define __inline_mathcodeNP2_(float_type, func, arg1, arg2, code) \
++  __MATH_INLINE float_type __NTH (func (float_type arg1, float_type arg2))    \
++  {									      \
++    code;								      \
++  }
++
++#  define __inline_mathcode3_(float_type, func, arg1, arg2, arg3, code) \
++  __MATH_INLINE float_type func (float_type, float_type, float_type) __THROW; \
++  __inline_mathcodeNP3_(float_type, func, arg1, arg2, arg3, code)
++
++#  define __inline_mathcodeNP3_(float_type, func, arg1, arg2, arg3, code) \
++  __MATH_INLINE float_type __NTH (func (float_type arg1, float_type arg2,     \
++					float_type arg3))		      \
++  {									      \
++    code;								      \
++  }
++# endif
++
++
++# if !defined __NO_MATH_INLINES && defined __OPTIMIZE__
++/* Miscellaneous functions  */
++
++/* __FAST_MATH__ is defined by gcc -ffast-math.  */
++#  ifdef __FAST_MATH__
++#   ifdef __USE_GNU
++#    define __sincos_code \
++  register long double __cosr;						      \
++  register long double __sinr;						      \
++  register unsigned int __swtmp;					      \
++  __asm __volatile__							      \
++    ("fsincos\n\t"							      \
++     "fnstsw	%w2\n\t"						      \
++     "testl	$0x400, %2\n\t"						      \
++     "jz	1f\n\t"							      \
++     "fldpi\n\t"							      \
++     "fadd	%%st(0)\n\t"						      \
++     "fxch	%%st(1)\n\t"						      \
++     "2: fprem1\n\t"							      \
++     "fnstsw	%w2\n\t"						      \
++     "testl	$0x400, %2\n\t"						      \
++     "jnz	2b\n\t"							      \
++     "fstp	%%st(1)\n\t"						      \
++     "fsincos\n\t"							      \
++     "1:"								      \
++     : "=t" (__cosr), "=u" (__sinr), "=a" (__swtmp) : "0" (__x));	      \
++  *__sinx = __sinr;							      \
++  *__cosx = __cosr
++
++__MATH_INLINE void
++__NTH (__sincos (double __x, double *__sinx, double *__cosx))
++{
++  __sincos_code;
++}
++
++__MATH_INLINE void
++__NTH (__sincosf (float __x, float *__sinx, float *__cosx))
++{
++  __sincos_code;
++}
++
++__MATH_INLINE void
++__NTH (__sincosl (long double __x, long double *__sinx, long double *__cosx))
++{
++  __sincos_code;
++}
++#   endif
++
++
++/* Optimized inline implementation, sometimes with reduced precision
++   and/or argument range.  */
++
++#   if __GNUC_PREREQ (3, 5)
++#    define __expm1_code \
++  register long double __temp;						      \
++  __temp = __builtin_expm1l (__x);					      \
++  return __temp ? __temp : __x
++#   else
++#    define __expm1_code \
++  register long double __value;						      \
++  register long double __exponent;					      \
++  register long double __temp;						      \
++  __asm __volatile__							      \
++    ("fldl2e			# e^x - 1 = 2^(x * log2(e)) - 1\n\t"	      \
++     "fmul	%%st(1)		# x * log2(e)\n\t"			      \
++     "fst	%%st(1)\n\t"						      \
++     "frndint			# int(x * log2(e))\n\t"			      \
++     "fxch\n\t"								      \
++     "fsub	%%st(1)		# fract(x * log2(e))\n\t"		      \
++     "f2xm1			# 2^(fract(x * log2(e))) - 1\n\t"	      \
++     "fscale			# 2^(x * log2(e)) - 2^(int(x * log2(e)))\n\t" \
++     : "=t" (__value), "=u" (__exponent) : "0" (__x));			      \
++  __asm __volatile__							      \
++    ("fscale			# 2^int(x * log2(e))\n\t"		      \
++     : "=t" (__temp) : "0" (1.0), "u" (__exponent));			      \
++  __temp -= 1.0;							      \
++  __temp += __value;							      \
++  return __temp ? __temp : __x
++#   endif
++__inline_mathcodeNP_ (long double, __expm1l, __x, __expm1_code)
++
++#   if __GNUC_PREREQ (3, 4)
++__inline_mathcodeNP_ (long double, __expl, __x, return __builtin_expl (__x))
++#   else
++#    define __exp_code \
++  register long double __value;						      \
++  register long double __exponent;					      \
++  __asm __volatile__							      \
++    ("fldl2e			# e^x = 2^(x * log2(e))\n\t"		      \
++     "fmul	%%st(1)		# x * log2(e)\n\t"			      \
++     "fst	%%st(1)\n\t"						      \
++     "frndint			# int(x * log2(e))\n\t"			      \
++     "fxch\n\t"								      \
++     "fsub	%%st(1)		# fract(x * log2(e))\n\t"		      \
++     "f2xm1			# 2^(fract(x * log2(e))) - 1\n\t"	      \
++     : "=t" (__value), "=u" (__exponent) : "0" (__x));			      \
++  __value += 1.0;							      \
++  __asm __volatile__							      \
++    ("fscale"								      \
++     : "=t" (__value) : "0" (__value), "u" (__exponent));		      \
++  return __value
++__inline_mathcodeNP (exp, __x, __exp_code)
++__inline_mathcodeNP_ (long double, __expl, __x, __exp_code)
++#   endif
++
++
++#   if !__GNUC_PREREQ (3, 5)
++__inline_mathcodeNP (tan, __x, \
++  register long double __value;						      \
++  register long double __value2 __attribute__ ((__unused__));		      \
++  __asm __volatile__							      \
++    ("fptan"								      \
++     : "=t" (__value2), "=u" (__value) : "0" (__x));			      \
++  return __value)
++#   endif
++#  endif /* __FAST_MATH__ */
++
++
++#  if __GNUC_PREREQ (3, 4)
++__inline_mathcodeNP2_ (long double, __atan2l, __y, __x,
++		       return __builtin_atan2l (__y, __x))
++#  else
++#   define __atan2_code \
++  register long double __value;						      \
++  __asm __volatile__							      \
++    ("fpatan"								      \
++     : "=t" (__value) : "0" (__x), "u" (__y) : "st(1)");		      \
++  return __value
++#   ifdef __FAST_MATH__
++__inline_mathcodeNP2 (atan2, __y, __x, __atan2_code)
++#   endif
++__inline_mathcodeNP2_ (long double, __atan2l, __y, __x, __atan2_code)
++#  endif
++
++
++#  if defined __FAST_MATH__ && !__GNUC_PREREQ (3, 5)
++__inline_mathcodeNP2 (fmod, __x, __y, \
++  register long double __value;						      \
++  __asm __volatile__							      \
++    ("1:	fprem\n\t"						      \
++     "fnstsw	%%ax\n\t"						      \
++     "sahf\n\t"								      \
++     "jp	1b"							      \
++     : "=t" (__value) : "0" (__x), "u" (__y) : "ax", "cc");		      \
++  return __value)
++#  endif
++
++
++#  ifdef __FAST_MATH__
++#   if !__GNUC_PREREQ (3,3)
++__inline_mathopNP (sqrt, "fsqrt")
++__inline_mathopNP_ (long double, __sqrtl, "fsqrt")
++#    define __libc_sqrtl(n) __sqrtl (n)
++#   else
++#    define __libc_sqrtl(n) __builtin_sqrtl (n)
++#   endif
++#  endif
++
++#  if __GNUC_PREREQ (2, 8)
++__inline_mathcodeNP_ (double, fabs, __x, return __builtin_fabs (__x))
++#   if defined __USE_MISC || defined __USE_ISOC99
++__inline_mathcodeNP_ (float, fabsf, __x, return __builtin_fabsf (__x))
++__inline_mathcodeNP_ (long double, fabsl, __x, return __builtin_fabsl (__x))
++#   endif
++__inline_mathcodeNP_ (long double, __fabsl, __x, return __builtin_fabsl (__x))
++#  else
++__inline_mathop (fabs, "fabs")
++__inline_mathop_ (long double, __fabsl, "fabs")
++# endif
++
++#  ifdef __FAST_MATH__
++#   if !__GNUC_PREREQ (3, 4)
++/* The argument range of this inline version is reduced.  */
++__inline_mathopNP (sin, "fsin")
++/* The argument range of this inline version is reduced.  */
++__inline_mathopNP (cos, "fcos")
++
++__inline_mathop_declNP (log, "fldln2; fxch; fyl2x", "0" (__x) : "st(1)")
++#   endif
++
++#   if !__GNUC_PREREQ (3, 5)
++__inline_mathop_declNP (log10, "fldlg2; fxch; fyl2x", "0" (__x) : "st(1)")
++
++__inline_mathcodeNP (asin, __x, return __atan2l (__x, __libc_sqrtl (1.0 - __x * __x)))
++__inline_mathcodeNP (acos, __x, return __atan2l (__libc_sqrtl (1.0 - __x * __x), __x))
++#   endif
++
++#   if !__GNUC_PREREQ (3, 4)
++__inline_mathop_declNP (atan, "fld1; fpatan", "0" (__x) : "st(1)")
++#   endif
++#  endif /* __FAST_MATH__ */
++
++__inline_mathcode_ (long double, __sgn1l, __x, \
++  __extension__ union { long double __xld; unsigned int __xi[3]; } __n =      \
++    { __xld: __x };							      \
++  __n.__xi[2] = (__n.__xi[2] & 0x8000) | 0x3fff;			      \
++  __n.__xi[1] = 0x80000000;						      \
++  __n.__xi[0] = 0;							      \
++  return __n.__xld)
++
++
++#  ifdef __FAST_MATH__
++/* The argument range of the inline version of sinhl is slightly reduced.  */
++__inline_mathcodeNP (sinh, __x, \
++  register long double __exm1 = __expm1l (__fabsl (__x));		      \
++  return 0.5 * (__exm1 / (__exm1 + 1.0) + __exm1) * __sgn1l (__x))
++
++__inline_mathcodeNP (cosh, __x, \
++  register long double __ex = __expl (__x);				      \
++  return 0.5 * (__ex + 1.0 / __ex))
++
++__inline_mathcodeNP (tanh, __x, \
++  register long double __exm1 = __expm1l (-__fabsl (__x + __x));	      \
++  return __exm1 / (__exm1 + 2.0) * __sgn1l (-__x))
++#  endif
++
++__inline_mathcodeNP (floor, __x, \
++  register long double __value;						      \
++  register int __ignore;						      \
++  unsigned short int __cw;						      \
++  unsigned short int __cwtmp;						      \
++  __asm __volatile ("fnstcw %3\n\t"					      \
++		    "movzwl %3, %1\n\t"					      \
++		    "andl $0xf3ff, %1\n\t"				      \
++		    "orl $0x0400, %1\n\t"	/* rounding down */	      \
++		    "movw %w1, %2\n\t"					      \
++		    "fldcw %2\n\t"					      \
++		    "frndint\n\t"					      \
++		    "fldcw %3"						      \
++		    : "=t" (__value), "=&q" (__ignore), "=m" (__cwtmp),	      \
++		      "=m" (__cw)					      \
++		    : "0" (__x));					      \
++  return __value)
++
++__inline_mathcodeNP (ceil, __x, \
++  register long double __value;						      \
++  register int __ignore;						      \
++  unsigned short int __cw;						      \
++  unsigned short int __cwtmp;						      \
++  __asm __volatile ("fnstcw %3\n\t"					      \
++		    "movzwl %3, %1\n\t"					      \
++		    "andl $0xf3ff, %1\n\t"				      \
++		    "orl $0x0800, %1\n\t"	/* rounding up */	      \
++		    "movw %w1, %2\n\t"					      \
++		    "fldcw %2\n\t"					      \
++		    "frndint\n\t"					      \
++		    "fldcw %3"						      \
++		    : "=t" (__value), "=&q" (__ignore), "=m" (__cwtmp),	      \
++		      "=m" (__cw)					      \
++		    : "0" (__x));					      \
++  return __value)
++
++#  ifdef __FAST_MATH__
++#   define __ldexp_code \
++  register long double __value;						      \
++  __asm __volatile__							      \
++    ("fscale"								      \
++     : "=t" (__value) : "0" (__x), "u" ((long double) __y));		      \
++  return __value
++
++__MATH_INLINE double
++__NTH (ldexp (double __x, int __y))
++{
++  __ldexp_code;
++}
++#  endif
++
++
++/* Optimized versions for some non-standardized functions.  */
++#  if defined __USE_ISOC99 || defined __USE_MISC
++
++#   ifdef __FAST_MATH__
++__inline_mathcodeNP (expm1, __x, __expm1_code)
++
++/* We cannot rely on M_SQRT being defined.  So we do it for ourself
++   here.  */
++#    define __M_SQRT2	1.41421356237309504880L	/* sqrt(2) */
++
++#    if !__GNUC_PREREQ (3, 5)
++__inline_mathcodeNP (log1p, __x, \
++  register long double __value;						      \
++  if (__fabsl (__x) >= 1.0 - 0.5 * __M_SQRT2)				      \
++    __value = logl (1.0 + __x);						      \
++  else									      \
++    __asm __volatile__							      \
++      ("fldln2\n\t"							      \
++       "fxch\n\t"							      \
++       "fyl2xp1"							      \
++       : "=t" (__value) : "0" (__x) : "st(1)");				      \
++  return __value)
++#    endif
++
++
++/* The argument range of the inline version of asinhl is slightly reduced.  */
++__inline_mathcodeNP (asinh, __x, \
++  register long double  __y = __fabsl (__x);				      \
++  return (log1pl (__y * __y / (__libc_sqrtl (__y * __y + 1.0) + 1.0) + __y)   \
++	  * __sgn1l (__x)))
++
++__inline_mathcodeNP (acosh, __x, \
++  return logl (__x + __libc_sqrtl (__x - 1.0) * __libc_sqrtl (__x + 1.0)))
++
++__inline_mathcodeNP (atanh, __x, \
++  register long double __y = __fabsl (__x);				      \
++  return -0.5 * log1pl (-(__y + __y) / (1.0 + __y)) * __sgn1l (__x))
++
++/* The argument range of the inline version of hypotl is slightly reduced.  */
++__inline_mathcodeNP2 (hypot, __x, __y,
++		      return __libc_sqrtl (__x * __x + __y * __y))
++
++#    if !__GNUC_PREREQ (3, 5)
++__inline_mathcodeNP(logb, __x, \
++  register long double __value;						      \
++  register long double __junk;						      \
++  __asm __volatile__							      \
++    ("fxtract\n\t"							      \
++     : "=t" (__junk), "=u" (__value) : "0" (__x));			      \
++  return __value)
++#    endif
++
++#   endif
++#  endif
++
++#  ifdef __USE_ISOC99
++#   ifdef __FAST_MATH__
++
++#    if !__GNUC_PREREQ (3, 5)
++__inline_mathop_declNP (log2, "fld1; fxch; fyl2x", "0" (__x) : "st(1)")
++#    endif
++
++__MATH_INLINE float
++__NTH (ldexpf (float __x, int __y))
++{
++  __ldexp_code;
++}
++
++__MATH_INLINE long double
++__NTH (ldexpl (long double __x, int __y))
++{
++  __ldexp_code;
++}
++
++__inline_mathopNP (rint, "frndint")
++#   endif /* __FAST_MATH__ */
++
++#   define __lrint_code \
++  long int __lrintres;							      \
++  __asm__ __volatile__							      \
++    ("fistpl %0"							      \
++     : "=m" (__lrintres) : "t" (__x) : "st");				      \
++  return __lrintres
++__MATH_INLINE long int
++__NTH (lrintf (float __x))
++{
++  __lrint_code;
++}
++__MATH_INLINE long int
++__NTH (lrint (double __x))
++{
++  __lrint_code;
++}
++__MATH_INLINE long int
++__NTH (lrintl (long double __x))
++{
++  __lrint_code;
++}
++#   undef __lrint_code
++
++#   define __llrint_code \
++  long long int __llrintres;						      \
++  __asm__ __volatile__							      \
++    ("fistpll %0"							      \
++     : "=m" (__llrintres) : "t" (__x) : "st");				      \
++  return __llrintres
++__MATH_INLINE long long int
++__NTH (llrintf (float __x))
++{
++  __llrint_code;
++}
++__MATH_INLINE long long int
++__NTH (llrint (double __x))
++{
++  __llrint_code;
++}
++__MATH_INLINE long long int
++__NTH (llrintl (long double __x))
++{
++  __llrint_code;
++}
++#   undef __llrint_code
++
++# endif
++
++
++#  ifdef __USE_MISC
++
++#   if defined __FAST_MATH__ && !__GNUC_PREREQ (3, 5)
++__inline_mathcodeNP2 (drem, __x, __y, \
++  register double __value;						      \
++  register int __clobbered;						      \
++  __asm __volatile__							      \
++    ("1:	fprem1\n\t"						      \
++     "fstsw	%%ax\n\t"						      \
++     "sahf\n\t"								      \
++     "jp	1b"							      \
++     : "=t" (__value), "=&a" (__clobbered) : "0" (__x), "u" (__y) : "cc");    \
++  return __value)
++#  endif
++
++
++/* This function is used in the `isfinite' macro.  */
++__MATH_INLINE int
++__NTH (__finite (double __x))
++{
++  return (__extension__
++	  (((((union { double __d; int __i[2]; }) {__d: __x}).__i[1]
++	     | 0x800fffffu) + 1) >> 31));
++}
++
++#  endif /* __USE_MISC  */
++
++/* Undefine some of the large macros which are not used anymore.  */
++#  undef __atan2_code
++#  ifdef __FAST_MATH__
++#   undef __expm1_code
++#   undef __exp_code
++#   undef __sincos_code
++#  endif /* __FAST_MATH__ */
++
++# endif /* __NO_MATH_INLINES  */
++
++
++/* This code is used internally in the GNU libc.  */
++# ifdef __LIBC_INTERNAL_MATH_INLINES
++__inline_mathop (__ieee754_sqrt, "fsqrt")
++__inline_mathcode2 (__ieee754_atan2, __y, __x,
++		    register long double __value;
++		    __asm __volatile__ ("fpatan\n\t"
++					: "=t" (__value)
++					: "0" (__x), "u" (__y) : "st(1)");
++		    return __value;)
++# endif
++
++#endif /* !__x86_64__ */
+diff -urN a/sysdeps/x86_64/fpu/bits/mathinline.h b/sysdeps/x86_64/fpu/bits/mathinline.h
+--- a/sysdeps/x86_64/fpu/bits/mathinline.h	2014-01-31 12:30:22.937839212 +0000
++++ b/sysdeps/x86_64/fpu/bits/mathinline.h	1970-01-01 00:00:00.000000000 +0000
+@@ -1,234 +0,0 @@
+-/* Inline math functions for x86-64.
+-   Copyright (C) 2002-2004, 2007, 2009, 2011 Free Software Foundation, Inc.
+-   This file is part of the GNU C Library.
+-
+-   The GNU C Library is free software; you can redistribute it and/or
+-   modify it under the terms of the GNU Lesser General Public
+-   License as published by the Free Software Foundation; either
+-   version 2.1 of the License, or (at your option) any later version.
+-
+-   The GNU C Library is distributed in the hope that it will be useful,
+-   but WITHOUT ANY WARRANTY; without even the implied warranty of
+-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+-   Lesser General Public License for more details.
+-
+-   You should have received a copy of the GNU Lesser General Public
+-   License along with the GNU C Library; if not, write to the Free
+-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+-   02111-1307 USA.  */
+-
+-#ifndef _MATH_H
+-# error "Never use <bits/mathinline.h> directly; include <math.h> instead."
+-#endif
+-
+-#include <bits/wordsize.h>
+-
+-#ifndef __extern_always_inline
+-# define __MATH_INLINE __inline
+-#else
+-# define __MATH_INLINE __extern_always_inline
+-#endif
+-
+-
+-/* The gcc, version 2.7 or below, has problems with all this inlining
+-   code.  So disable it for this version of the compiler.  */
+-#if __GNUC_PREREQ (2, 8) && defined __USE_ISOC99
+-__BEGIN_NAMESPACE_C99
+-
+-/* Test for negative number.  Used in the signbit() macro.  */
+-__MATH_INLINE int
+-__NTH (__signbitf (float __x))
+-{
+-# if __WORDSIZE == 32
+-  __extension__ union { float __f; int __i; } __u = { __f: __x };
+-  return __u.__i < 0;
+-# else
+-  int __m;
+-  __asm ("pmovmskb %1, %0" : "=r" (__m) : "x" (__x));
+-  return __m & 0x8;
+-# endif
+-}
+-__MATH_INLINE int
+-__NTH (__signbit (double __x))
+-{
+-# if __WORDSIZE == 32
+-  __extension__ union { double __d; int __i[2]; } __u = { __d: __x };
+-  return __u.__i[1] < 0;
+-# else
+-  int __m;
+-  __asm ("pmovmskb %1, %0" : "=r" (__m) : "x" (__x));
+-  return __m & 0x80;
+-# endif
+-}
+-__MATH_INLINE int
+-__NTH (__signbitl (long double __x))
+-{
+-  __extension__ union { long double __l; int __i[3]; } __u = { __l: __x };
+-  return (__u.__i[2] & 0x8000) != 0;
+-}
+-
+-__END_NAMESPACE_C99
+-#endif
+-
+-
+-#if (__GNUC_PREREQ (2, 8) && !defined __NO_MATH_INLINES \
+-     && defined __OPTIMIZE__)
+-
+-# ifdef __USE_ISOC99
+-__BEGIN_NAMESPACE_C99
+-
+-/* Round to nearest integer.  */
+-#  if __WORDSIZE == 64 || defined __SSE_MATH__
+-__MATH_INLINE long int
+-__NTH (lrintf (float __x))
+-{
+-  long int __res;
+-  __asm ("cvtss2si %1, %0" : "=r" (__res) : "xm" (__x));
+-  return __res;
+-}
+-#  endif
+-#  if __WORDSIZE == 64 || defined __SSE2_MATH__
+-__MATH_INLINE long int
+-__NTH (lrint (double __x))
+-{
+-  long int __res;
+-  __asm ("cvtsd2si %1, %0" : "=r" (__res) : "xm" (__x));
+-  return __res;
+-}
+-#  endif
+-#  if __WORDSIZE == 64
+-__MATH_INLINE long long int
+-__NTH (llrintf (float __x))
+-{
+-  long long int __res;
+-  __asm ("cvtss2si %1, %0" : "=r" (__res) : "xm" (__x));
+-  return __res;
+-}
+-__MATH_INLINE long long int
+-__NTH (llrint (double __x))
+-{
+-  long long int __res;
+-  __asm ("cvtsd2si %1, %0" : "=r" (__res) : "xm" (__x));
+-  return __res;
+-}
+-#  endif
+-
+-#  if defined __FINITE_MATH_ONLY__ && __FINITE_MATH_ONLY__ > 0 \
+-      && (__WORDSIZE == 64 || defined __SSE2_MATH__)
+-/* Determine maximum of two values.  */
+-__MATH_INLINE float
+-__NTH (fmaxf (float __x, float __y))
+-{
+-  __asm ("maxss %1, %0" : "+x" (__x) : "xm" (__y));
+-  return __x;
+-}
+-__MATH_INLINE double
+-__NTH (fmax (double __x, double __y))
+-{
+-  __asm ("maxsd %1, %0" : "+x" (__x) : "xm" (__y));
+-  return __x;
+-}
+-
+-/* Determine minimum of two values.  */
+-__MATH_INLINE float
+-__NTH (fminf (float __x, float __y))
+-{
+-  __asm ("minss %1, %0" : "+x" (__x) : "xm" (__y));
+-  return __x;
+-}
+-__MATH_INLINE double
+-__NTH (fmin (double __x, double __y))
+-{
+-  __asm ("minsd %1, %0" : "+x" (__x) : "xm" (__y));
+-  return __x;
+-}
+-#  endif
+-
+-__END_NAMESPACE_C99
+-# endif
+-
+-# if defined __SSE4_1__ && (__WORDSIZE == 64 || defined __SSE2_MATH__)
+-#  if defined __USE_MISC || defined __USE_XOPEN_EXTENDED || defined __USE_ISOC99
+-__BEGIN_NAMESPACE_C99
+-
+-/* Round to nearest integer.  */
+-__MATH_INLINE double
+-__NTH (rint (double __x))
+-{
+-  double __res;
+-  __asm ("roundsd $4, %1, %0" : "=x" (__res) : "xm" (__x));
+-  return __res;
+-}
+-__MATH_INLINE float
+-__NTH (rintf (float __x))
+-{
+-  float __res;
+-  __asm ("roundss $4, %1, %0" : "=x" (__res) : "xm" (__x));
+-  return __res;
+-}
+-
+-#   ifdef __USE_ISOC99
+-/* Round to nearest integer without raising inexact exception.  */
+-__MATH_INLINE double
+-__NTH (nearbyint (double __x))
+-{
+-  double __res;
+-  __asm ("roundsd $0xc, %1, %0" : "=x" (__res) : "xm" (__x));
+-  return __res;
+-}
+-__MATH_INLINE float
+-__NTH (nearbyintf (float __x))
+-{
+-  float __res;
+-  __asm ("roundss $0xc, %1, %0" : "=x" (__res) : "xm" (__x));
+-  return __res;
+-}
+-#   endif
+-
+-__END_NAMESPACE_C99
+-#  endif
+-
+-__BEGIN_NAMESPACE_STD
+-/* Smallest integral value not less than X.  */
+-__MATH_INLINE double
+-__NTH (ceil (double __x))
+-{
+-  double __res;
+-  __asm ("roundsd $2, %1, %0" : "=x" (__res) : "xm" (__x));
+-  return __res;
+-}
+-__END_NAMESPACE_STD
+-
+-__BEGIN_NAMESPACE_C99
+-__MATH_INLINE float
+-__NTH (ceilf (float __x))
+-{
+-  float __res;
+-  __asm ("roundss $2, %1, %0" : "=x" (__res) : "xm" (__x));
+-  return __res;
+-}
+-__END_NAMESPACE_C99
+-
+-__BEGIN_NAMESPACE_STD
+-/* Largest integer not greater than X.  */
+-__MATH_INLINE double
+-__NTH (floor (double __x))
+-{
+-  double __res;
+-  __asm ("roundsd $1, %1, %0" : "=x" (__res) : "xm" (__x));
+-  return __res;
+-}
+-__END_NAMESPACE_STD
+-
+-__BEGIN_NAMESPACE_C99
+-__MATH_INLINE float
+-__NTH (floorf (float __x))
+-{
+-  float __res;
+-  __asm ("roundss $1, %1, %0" : "=x" (__res) : "xm" (__x));
+-  return __res;
+-}
+-__END_NAMESPACE_C99
+-# endif
+-
+-#endif
diff --git a/patches/glibc/2.15/014-BZ14117-Use-__volatile__-to-access-fpu-control-word.patch b/patches/glibc/2.15/014-BZ14117-Use-__volatile__-to-access-fpu-control-word.patch
new file mode 100644
index 0000000..18db4de
--- /dev/null
+++ b/patches/glibc/2.15/014-BZ14117-Use-__volatile__-to-access-fpu-control-word.patch
@@ -0,0 +1,56 @@
+From 3ee947b1244a4562e8934b98f39e17f98d2309da Mon Sep 17 00:00:00 2001
+From: "H.J. Lu" <hjl.tools@gmail.com>
+Date: Mon, 18 Jun 2012 11:09:58 -0700
+Subject: [PATCH] Use __volatile__ to access fpu control word
+
+---
+ ChangeLog                    |  6 ++++++
+ sysdeps/x86_64/fpu_control.h | 19 ++++++++++++++-----
+ 2 files changed, 20 insertions(+), 5 deletions(-)
+
+diff -urN a/ChangeLog b/ChangeLog
+--- a/ChangeLog	2014-01-31 12:38:56.474509983 +0000
++++ b/ChangeLog	2014-01-31 12:37:32.074509353 +0000
+@@ -1,3 +1,9 @@
++2012-06-18  H.J. Lu  <hongjiu.lu@intel.com>
++
++       [BZ #14117]
++       * sysdeps/x86_64/fpu_control.h (_FPU_GETCW): Add __volatile__.
++       (_FPU_SETCW): Likewise.
++
+ 2014-01-31  Ray Donnelly <mingw.android@gmail.com>
+ 
+        [BZ #14117]
+diff -urN a/sysdeps/x86_64/fpu_control.h b/sysdeps/x86_64/fpu_control.h
+--- a/sysdeps/x86_64/fpu_control.h	2012-01-01 12:16:32.000000000 +0000
++++ b/sysdeps/x86_64/fpu_control.h	2014-01-31 12:36:49.067842324 +0000
+@@ -1,5 +1,5 @@
+-/* FPU control word bits.  x86-64 version.
+-   Copyright (C) 1993,1995,1996,1997,1998,2000,2001,2002 Free Software Foundation, Inc.
++/* FPU control word bits.  x86 version.
++   Copyright (C) 1993-2012 Free Software Foundation, Inc.
+    This file is part of the GNU C Library.
+    Contributed by Olaf Flebbe.
+ 
+@@ -91,9 +91,18 @@
+ /* Type of the control word.  */
+ typedef unsigned int fpu_control_t __attribute__ ((__mode__ (__HI__)));
+ 
+-/* Macros for accessing the hardware control word.  */
+-#define _FPU_GETCW(cw) __asm__ ("fnstcw %0" : "=m" (*&cw))
+-#define _FPU_SETCW(cw) __asm__ ("fldcw %0" : : "m" (*&cw))
++/* Macros for accessing the hardware control word.  "*&" is used to
++   work around a bug in older versions of GCC.  __volatile__ is used
++   to support combination of writing the control register and reading
++   it back.  Without __volatile__, the old value may be used for reading
++   back under compiler optimization.
++
++   Note that the use of these macros is not sufficient anymore with
++   recent hardware nor on x86-64.  Some floating point operations are
++   executed in the SSE/SSE2 engines which have their own control and
++   status register.  */
++#define _FPU_GETCW(cw) __asm__ __volatile__ ("fnstcw %0" : "=m" (*&cw))
++#define _FPU_SETCW(cw) __asm__ __volatile__ ("fldcw %0" : : "m" (*&cw))
+ 
+ /* Default control word set at startup.  */
+ extern fpu_control_t __fpu_control;
-- 
1.8.5.3

